diff --git a/cmd/outline-ss-server/config_example.yml b/cmd/outline-ss-server/config_example.yml
index 8895b86..b005451 100644
--- a/cmd/outline-ss-server/config_example.yml
+++ b/cmd/outline-ss-server/config_example.yml
@@ -1,15 +1,19 @@
+bind_address: "127.0.0.1"
 keys:
   - id: user-0
     port: 9000
     cipher: chacha20-ietf-poly1305
     secret: Secret0
+    rate_limit: 128000
 
   - id: user-1
     port: 9000
     cipher: chacha20-ietf-poly1305
     secret: Secret1
+    rate_limit: 128000
 
   - id: user-2
     port: 9001
     cipher: chacha20-ietf-poly1305
     secret: Secret2
+    rate_limit: 128000
diff --git a/cmd/outline-ss-server/main.go b/cmd/outline-ss-server/main.go
index 748003e..5d09e71 100644
--- a/cmd/outline-ss-server/main.go
+++ b/cmd/outline-ss-server/main.go
@@ -49,7 +49,7 @@ const tcpReadTimeout time.Duration = 59 * time.Second
 const defaultNatTimeout time.Duration = 5 * time.Minute
 
 func init() {
-	var prefix = "%{level:.1s}%{time:2006-01-02T15:04:05.000Z07:00} %{pid} %{shortfile}]"
+	prefix := "%{level:.1s}%{time:2006-01-02T15:04:05.000Z07:00} %{pid} %{shortfile}]"
 	if term.IsTerminal(int(os.Stderr.Fd())) {
 		// Add color only if the output is the terminal
 		prefix = strings.Join([]string{"%{color}", prefix, "%{color:reset}"}, "")
@@ -72,14 +72,15 @@ type SSServer struct {
 	ports       map[int]*ssPort
 }
 
-func (s *SSServer) startPort(portNum int) error {
-	listener, err := net.ListenTCP("tcp", &net.TCPAddr{Port: portNum})
+func (s *SSServer) startPort(portNum int, ipAddr string, trafficLimiterConfig *service.TrafficLimiterConfig) error {
+	listenIP := net.ParseIP(ipAddr)
+	listener, err := net.ListenTCP("tcp", &net.TCPAddr{Port: portNum, IP: listenIP})
 	if err != nil {
 		//lint:ignore ST1005 Shadowsocks is capitalized.
 		return fmt.Errorf("Shadowsocks TCP service failed to start on port %v: %w", portNum, err)
 	}
 	logger.Infof("Shadowsocks TCP service listening on %v", listener.Addr().String())
-	packetConn, err := net.ListenUDP("udp", &net.UDPAddr{Port: portNum})
+	packetConn, err := net.ListenUDP("udp", &net.UDPAddr{Port: portNum, IP: listenIP})
 	if err != nil {
 		//lint:ignore ST1005 Shadowsocks is capitalized.
 		return fmt.Errorf("Shadowsocks UDP service failed to start on port %v: %w", portNum, err)
@@ -87,8 +88,9 @@ func (s *SSServer) startPort(portNum int) error {
 	logger.Infof("Shadowsocks UDP service listening on %v", packetConn.LocalAddr().String())
 	port := &ssPort{tcpListener: listener, packetConn: packetConn, cipherList: service.NewCipherList()}
 	// TODO: Register initial data metrics at zero.
-	tcpHandler := service.NewTCPHandler(portNum, port.cipherList, &s.replayCache, s.m, tcpReadTimeout)
-	packetHandler := service.NewPacketHandler(s.natTimeout, port.cipherList, s.m)
+	limiter := service.NewTrafficLimiter(trafficLimiterConfig)
+	tcpHandler := service.NewTCPHandler(portNum, port.cipherList, &s.replayCache, s.m, tcpReadTimeout, limiter)
+	packetHandler := service.NewPacketHandler(s.natTimeout, port.cipherList, s.m, limiter)
 	s.ports[portNum] = port
 	accept := func() (transport.StreamConn, error) {
 		conn, err := listener.AcceptTCP()
@@ -123,14 +125,21 @@ func (s *SSServer) removePort(portNum int) error {
 	return nil
 }
 
-func (s *SSServer) loadConfig(filename string) error {
+func (s *SSServer) loadConfig(filename string, bindAddrForOverwrite string) error {
 	config, err := readConfig(filename)
 	if err != nil {
 		return fmt.Errorf("failed to load config (%v): %w", filename, err)
 	}
 
+	bindAddr := config.BindAddress
+	// Overwrite config file
+	if bindAddrForOverwrite != "" {
+		bindAddr = bindAddrForOverwrite
+	}
+
 	portChanges := make(map[int]int)
 	portCiphers := make(map[int]*list.List) // Values are *List of *CipherEntry.
+	portKeyLimits := make(map[int]map[string]int)
 	for _, keyConfig := range config.Keys {
 		portChanges[keyConfig.Port] = 1
 		cipherList, ok := portCiphers[keyConfig.Port]
@@ -144,6 +153,13 @@ func (s *SSServer) loadConfig(filename string) error {
 		}
 		entry := service.MakeCipherEntry(keyConfig.ID, cryptoKey, keyConfig.Secret)
 		cipherList.PushBack(&entry)
+		var keyLimits map[string]int
+		keyLimits, ok = portKeyLimits[keyConfig.Port]
+		if !ok {
+			keyLimits = make(map[string]int)
+			portKeyLimits[keyConfig.Port] = keyLimits
+		}
+		keyLimits[keyConfig.ID] = keyConfig.RateLimit
 	}
 	for port := range s.ports {
 		portChanges[port] = portChanges[port] - 1
@@ -154,7 +170,8 @@ func (s *SSServer) loadConfig(filename string) error {
 				return fmt.Errorf("failed to remove port %v: %w", portNum, err)
 			}
 		} else if count == +1 {
-			if err := s.startPort(portNum); err != nil {
+			trafficLimiterConfig := &service.TrafficLimiterConfig{KeyToRateLimit: portKeyLimits[portNum]}
+			if err := s.startPort(portNum, bindAddr, trafficLimiterConfig); err != nil {
 				return err
 			}
 		}
@@ -178,14 +195,16 @@ func (s *SSServer) Stop() error {
 }
 
 // RunSSServer starts a shadowsocks server running, and returns the server or an error.
-func RunSSServer(filename string, natTimeout time.Duration, sm *outlineMetrics, replayHistory int) (*SSServer, error) {
+func RunSSServer(filename string, natTimeout time.Duration, sm *outlineMetrics, replayHistory int,
+	bindAddr string,
+) (*SSServer, error) {
 	server := &SSServer{
 		natTimeout:  natTimeout,
 		m:           sm,
 		replayCache: service.NewReplayCache(replayHistory),
 		ports:       make(map[int]*ssPort),
 	}
-	err := server.loadConfig(filename)
+	err := server.loadConfig(filename, bindAddr)
 	if err != nil {
 		return nil, fmt.Errorf("failed configure server: %w", err)
 	}
@@ -194,7 +213,7 @@ func RunSSServer(filename string, natTimeout time.Duration, sm *outlineMetrics,
 	go func() {
 		for range sigHup {
 			logger.Infof("SIGHUP received. Loading config from %v", filename)
-			if err := server.loadConfig(filename); err != nil {
+			if err := server.loadConfig(filename, bindAddr); err != nil {
 				logger.Errorf("Failed to update server: %v. Server state may be invalid. Fix the error and try the update again", err)
 			}
 		}
@@ -203,11 +222,13 @@ func RunSSServer(filename string, natTimeout time.Duration, sm *outlineMetrics,
 }
 
 type Config struct {
-	Keys []struct {
-		ID     string
-		Port   int
-		Cipher string
-		Secret string
+	BindAddress string
+	Keys        []struct {
+		ID        string
+		Port      int
+		Cipher    string
+		Secret    string
+		RateLimit int
 	}
 }
 
@@ -230,6 +251,7 @@ func main() {
 		MetricsAddr   string
 		IPCountryDB   string
 		IPASNDB       string
+		BindAddr      string
 		natTimeout    time.Duration
 		replayHistory int
 		Verbose       bool
@@ -244,6 +266,8 @@ func main() {
 	flag.BoolVar(&flags.Verbose, "verbose", false, "Enables verbose logging output")
 	flag.BoolVar(&flags.Version, "version", false, "The version of the server")
 
+	flag.StringVar(&flags.BindAddr, "bind_addr", "", "IP address to bind to (overwrites config file)")
+
 	flag.Parse()
 
 	if flags.Verbose {
@@ -285,7 +309,7 @@ func main() {
 
 	m := newPrometheusOutlineMetrics(ip2info, prometheus.DefaultRegisterer)
 	m.SetBuildInfo(version)
-	_, err = RunSSServer(flags.ConfigFile, flags.natTimeout, m, flags.replayHistory)
+	_, err = RunSSServer(flags.ConfigFile, flags.natTimeout, m, flags.replayHistory, flags.BindAddr)
 	if err != nil {
 		logger.Fatalf("Server failed to start: %v. Aborting", err)
 	}
diff --git a/cmd/outline-ss-server/server_test.go b/cmd/outline-ss-server/server_test.go
index 0b7777b..e41f693 100644
--- a/cmd/outline-ss-server/server_test.go
+++ b/cmd/outline-ss-server/server_test.go
@@ -23,7 +23,7 @@ import (
 
 func TestRunSSServer(t *testing.T) {
 	m := newPrometheusOutlineMetrics(nil, prometheus.DefaultRegisterer)
-	server, err := RunSSServer("config_example.yml", 30*time.Second, m, 10000)
+	server, err := RunSSServer("config_example.yml", 30*time.Second, m, 10000, "")
 	if err != nil {
 		t.Fatalf("RunSSServer() error = %v", err)
 	}
diff --git a/internal/integration_test/integration_test.go b/internal/integration_test/integration_test.go
index ecb5ee2..68b7c48 100644
--- a/internal/integration_test/integration_test.go
+++ b/internal/integration_test/integration_test.go
@@ -99,6 +99,11 @@ func startUDPEchoServer(t testing.TB) (*net.UDPConn, *sync.WaitGroup) {
 	return conn, &running
 }
 
+func makeLimiter(cipherList service.CipherList) service.TrafficLimiter {
+	c := service.MakeTestTrafficLimiterConfig(cipherList)
+	return service.NewTrafficLimiter(&c)
+}
+
 func TestTCPEcho(t *testing.T) {
 	echoListener, echoRunning := startTCPEchoServer(t)
 
@@ -113,7 +118,7 @@ func TestTCPEcho(t *testing.T) {
 	}
 	replayCache := service.NewReplayCache(5)
 	const testTimeout = 200 * time.Millisecond
-	handler := service.NewTCPHandler(proxyListener.Addr().(*net.TCPAddr).Port, cipherList, &replayCache, &service.NoOpTCPMetrics{}, testTimeout)
+	handler := service.NewTCPHandler(proxyListener.Addr().(*net.TCPAddr).Port, cipherList, &replayCache, &service.NoOpTCPMetrics{}, testTimeout, makeLimiter(cipherList))
 	handler.SetTargetIPValidator(allowAll)
 	done := make(chan struct{})
 	go func() {
@@ -161,6 +166,183 @@ func TestTCPEcho(t *testing.T) {
 	echoRunning.Wait()
 }
 
+func TestTrafficLimiterTCP(t *testing.T) {
+	echoListener, echoRunning := startTCPEchoServer(t)
+
+	proxyListener, err := net.ListenTCP("tcp", &net.TCPAddr{IP: net.ParseIP("127.0.0.1"), Port: 0})
+	if err != nil {
+		t.Fatalf("ListenTCP failed: %v", err)
+	}
+	secrets := sstest.MakeTestSecrets(1)
+	cipherList, err := service.MakeTestCiphers(secrets)
+	if err != nil {
+		t.Fatal(err)
+	}
+	replayCache := service.NewReplayCache(5)
+	const testTimeout = 5 * time.Second
+
+	key := cipherList.SnapshotForClientIP(net.IP{})[0].Value.(*service.CipherEntry).ID
+	trafficLimiter := service.NewTrafficLimiter(&service.TrafficLimiterConfig{
+		KeyToRateLimit: map[string]int{
+			key: 1000,
+		},
+	})
+
+	handler := service.NewTCPHandler(proxyListener.Addr().(*net.TCPAddr).Port, cipherList, &replayCache, &service.NoOpTCPMetrics{}, testTimeout, trafficLimiter)
+	handler.SetTargetIPValidator(allowAll)
+	done := make(chan struct{})
+	go func() {
+		service.StreamServe(func() (transport.StreamConn, error) { return proxyListener.AcceptTCP() }, handler.Handle)
+		done <- struct{}{}
+	}()
+
+	cryptoKey, err := shadowsocks.NewEncryptionKey(shadowsocks.CHACHA20IETFPOLY1305, secrets[0])
+	require.NoError(t, err)
+	client, err := shadowsocks.NewStreamDialer(&transport.TCPEndpoint{Address: proxyListener.Addr().String()}, cryptoKey)
+	require.NoError(t, err)
+
+	doWriteRead := func(N int, repeats int) time.Duration {
+		up := sstest.MakeTestPayload(N)
+		conn, err := client.Dial(context.Background(), echoListener.Addr().String())
+		require.NoError(t, err)
+
+		defer conn.Close()
+
+		start := time.Now()
+		down := make([]byte, N)
+
+		for i := 0; i < repeats; i++ {
+			n, err := conn.Write(up)
+			if err != nil {
+				t.Fatal(err)
+			}
+			if n != N {
+				t.Fatalf("Tried to upload %d bytes, but only sent %d", N, n)
+			}
+
+			n, err = io.ReadFull(conn, down)
+			if err != nil && err != io.EOF {
+				t.Fatal(err)
+			}
+			if n != N {
+				t.Fatalf("Expected to download %d bytes, but only received %d", N, n)
+			}
+
+			if !bytes.Equal(up, down) {
+				t.Fatal("Echo mismatch")
+			}
+		}
+
+		return time.Now().Sub(start)
+	}
+
+	period1 := doWriteRead(200, 4)
+	if period1 < 500*time.Millisecond {
+		t.Fatalf("Write-read loop is too fast")
+	}
+	time.Sleep(1 * time.Second)
+
+	period2 := doWriteRead(200, 2)
+	if period2 > 100*time.Millisecond {
+		t.Fatalf("Write-read loop is too slow")
+	}
+
+	period3 := doWriteRead(500, 2)
+	if period3 < 500*time.Millisecond {
+		t.Fatalf("Write-read loop is too fast")
+	}
+
+	proxyListener.Close()
+	<-done
+	echoListener.Close()
+	echoRunning.Wait()
+}
+
+func TestTrafficLimiterUDP(t *testing.T) {
+	echoConn, echoRunning := startUDPEchoServer(t)
+
+	proxyConn, err := net.ListenUDP("udp", &net.UDPAddr{IP: net.ParseIP("127.0.0.1"), Port: 0})
+	if err != nil {
+		t.Fatalf("ListenTCP failed: %v", err)
+	}
+	secrets := sstest.MakeTestSecrets(1)
+	cipherList, err := service.MakeTestCiphers(secrets)
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	key := cipherList.SnapshotForClientIP(net.IP{})[0].Value.(*service.CipherEntry).ID
+	trafficLimiter := service.NewTrafficLimiter(&service.TrafficLimiterConfig{
+		KeyToRateLimit: map[string]int{
+			key: 1000,
+		},
+	})
+
+	testMetrics := &fakeUDPMetrics{}
+	proxy := service.NewPacketHandler(time.Hour, cipherList, testMetrics, trafficLimiter)
+	proxy.SetTargetIPValidator(allowAll)
+	done := make(chan struct{})
+	go func() {
+		proxy.Handle(proxyConn)
+		done <- struct{}{}
+	}()
+
+	cryptoKey, err := shadowsocks.NewEncryptionKey(shadowsocks.CHACHA20IETFPOLY1305, secrets[0])
+	require.NoError(t, err)
+	client, err := shadowsocks.NewPacketListener(&transport.UDPEndpoint{Address: proxyConn.LocalAddr().String()}, cryptoKey)
+	require.NoError(t, err)
+	conn, err := client.ListenPacket(context.Background())
+	require.NoError(t, err)
+
+	run := func(N int, expectReadError bool) {
+		up := sstest.MakeTestPayload(N)
+		n, err := conn.WriteTo(up, echoConn.LocalAddr())
+		if err != nil {
+			t.Fatal(err)
+		}
+		if n != N {
+			t.Fatalf("Tried to upload %d bytes, but only sent %d", N, n)
+		}
+
+		conn.SetReadDeadline(time.Now().Add(50 * time.Millisecond))
+
+		down := make([]byte, N)
+		n, addr, err := conn.ReadFrom(down)
+		if err != nil {
+			if !expectReadError {
+				t.Fatalf("Unexpected read error: %v", err)
+			}
+			return
+		} else {
+			if expectReadError {
+				t.Fatalf("Expected read error")
+			}
+		}
+		if n != N {
+			t.Fatalf("Tried to download %d bytes, but only sent %d", N, n)
+		}
+		if addr.String() != echoConn.LocalAddr().String() {
+			t.Errorf("Reported address mismatch: %s != %s", addr.String(), echoConn.LocalAddr().String())
+		}
+
+		if !bytes.Equal(up, down) {
+			t.Fatal("Echo mismatch")
+		}
+	}
+
+	for i := 0; i < 3; i++ {
+		run(300, false)
+		run(300, true)
+		time.Sleep(time.Second)
+	}
+
+	conn.Close()
+	echoConn.Close()
+	echoRunning.Wait()
+	proxyConn.Close()
+	<-done
+}
+
 type statusMetrics struct {
 	service.NoOpTCPMetrics
 	sync.Mutex
@@ -181,7 +363,7 @@ func TestRestrictedAddresses(t *testing.T) {
 	require.NoError(t, err)
 	const testTimeout = 200 * time.Millisecond
 	testMetrics := &statusMetrics{}
-	handler := service.NewTCPHandler(proxyListener.Addr().(*net.TCPAddr).Port, cipherList, nil, testMetrics, testTimeout)
+	handler := service.NewTCPHandler(proxyListener.Addr().(*net.TCPAddr).Port, cipherList, nil, testMetrics, testTimeout, makeLimiter(cipherList))
 	done := make(chan struct{})
 	go func() {
 		service.StreamServe(service.WrapStreamListener(proxyListener.AcceptTCP), handler.Handle)
@@ -241,15 +423,19 @@ var _ service.UDPMetrics = (*fakeUDPMetrics)(nil)
 func (m *fakeUDPMetrics) GetIPInfo(ip net.IP) (ipinfo.IPInfo, error) {
 	return ipinfo.IPInfo{CountryCode: "QQ"}, nil
 }
+
 func (m *fakeUDPMetrics) AddUDPPacketFromClient(clientInfo ipinfo.IPInfo, accessKey, status string, clientProxyBytes, proxyTargetBytes int) {
 	m.up = append(m.up, udpRecord{clientInfo, accessKey, status, clientProxyBytes, proxyTargetBytes})
 }
+
 func (m *fakeUDPMetrics) AddUDPPacketFromTarget(clientInfo ipinfo.IPInfo, accessKey, status string, targetProxyBytes, proxyClientBytes int) {
 	m.down = append(m.down, udpRecord{clientInfo, accessKey, status, targetProxyBytes, proxyClientBytes})
 }
+
 func (m *fakeUDPMetrics) AddUDPNatEntry() {
 	m.natAdded++
 }
+
 func (m *fakeUDPMetrics) RemoveUDPNatEntry() {
 	// Not tested because it requires waiting for a long timeout.
 }
@@ -268,7 +454,7 @@ func TestUDPEcho(t *testing.T) {
 		t.Fatal(err)
 	}
 	testMetrics := &fakeUDPMetrics{}
-	proxy := service.NewPacketHandler(time.Hour, cipherList, testMetrics)
+	proxy := service.NewPacketHandler(time.Hour, cipherList, testMetrics, makeLimiter(cipherList))
 	proxy.SetTargetIPValidator(allowAll)
 	done := make(chan struct{})
 	go func() {
@@ -361,7 +547,7 @@ func BenchmarkTCPThroughput(b *testing.B) {
 		b.Fatal(err)
 	}
 	const testTimeout = 200 * time.Millisecond
-	handler := service.NewTCPHandler(proxyListener.Addr().(*net.TCPAddr).Port, cipherList, nil, &service.NoOpTCPMetrics{}, testTimeout)
+	handler := service.NewTCPHandler(proxyListener.Addr().(*net.TCPAddr).Port, cipherList, nil, &service.NoOpTCPMetrics{}, testTimeout, makeLimiter(cipherList))
 	handler.SetTargetIPValidator(allowAll)
 	done := make(chan struct{})
 	go func() {
@@ -423,7 +609,7 @@ func BenchmarkTCPMultiplexing(b *testing.B) {
 	}
 	replayCache := service.NewReplayCache(service.MaxCapacity)
 	const testTimeout = 200 * time.Millisecond
-	handler := service.NewTCPHandler(proxyListener.Addr().(*net.TCPAddr).Port, cipherList, &replayCache, &service.NoOpTCPMetrics{}, testTimeout)
+	handler := service.NewTCPHandler(proxyListener.Addr().(*net.TCPAddr).Port, cipherList, &replayCache, &service.NoOpTCPMetrics{}, testTimeout, makeLimiter(cipherList))
 	handler.SetTargetIPValidator(allowAll)
 	done := make(chan struct{})
 	go func() {
@@ -496,7 +682,7 @@ func BenchmarkUDPEcho(b *testing.B) {
 	if err != nil {
 		b.Fatal(err)
 	}
-	proxy := service.NewPacketHandler(time.Hour, cipherList, &service.NoOpUDPMetrics{})
+	proxy := service.NewPacketHandler(time.Hour, cipherList, &service.NoOpUDPMetrics{}, makeLimiter(cipherList))
 	proxy.SetTargetIPValidator(allowAll)
 	done := make(chan struct{})
 	go func() {
@@ -540,7 +726,7 @@ func BenchmarkUDPManyKeys(b *testing.B) {
 	if err != nil {
 		b.Fatal(err)
 	}
-	proxy := service.NewPacketHandler(time.Hour, cipherList, &service.NoOpUDPMetrics{})
+	proxy := service.NewPacketHandler(time.Hour, cipherList, &service.NoOpUDPMetrics{}, makeLimiter(cipherList))
 	proxy.SetTargetIPValidator(allowAll)
 	done := make(chan struct{})
 	go func() {
diff --git a/service/limiter.go b/service/limiter.go
new file mode 100644
index 0000000..c8a1408
--- /dev/null
+++ b/service/limiter.go
@@ -0,0 +1,128 @@
+// Copyright 2018 Jigsaw Operations LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package service
+
+import (
+	"context"
+	"io"
+	"time"
+
+	"golang.org/x/time/rate"
+)
+
+type TrafficLimiterConfig struct {
+	// Rate limit in bytes per second.
+	// If the corresponding limit is zero, it means no limits
+	KeyToRateLimit map[string]int
+}
+
+type TrafficLimiter interface {
+	WrapReaderWriter(accessKey string, reader io.Reader, writer io.Writer) (io.Reader, io.Writer)
+	Allow(accessKey string, n int) bool
+}
+
+func NewTrafficLimiter(config *TrafficLimiterConfig) TrafficLimiter {
+	keyToLimiter := make(map[string]*rate.Limiter, len(config.KeyToRateLimit))
+	for accessKey, limit := range config.KeyToRateLimit {
+		var limiter *rate.Limiter
+		if limit == 0 {
+			limiter = nil
+		} else {
+			limiter = createLimiter(limit)
+		}
+		keyToLimiter[accessKey] = limiter
+	}
+	return &trafficLimiter{keyToLimiter: keyToLimiter}
+}
+
+type trafficLimiter struct {
+	keyToLimiter map[string]*rate.Limiter
+}
+
+// doWait does the waiting for any n, even exceeding the burst limit.
+func doWait(l *rate.Limiter, n int) error {
+	ctx := context.TODO()
+	b := l.Burst()
+	for b < n {
+		err := l.WaitN(ctx, b)
+		if err != nil {
+			return err
+		}
+		n -= b
+	}
+	return l.WaitN(ctx, n)
+}
+
+type limitedReader struct {
+	reader  io.Reader
+	limiter *rate.Limiter
+}
+
+func (r *limitedReader) Read(b []byte) (int, error) {
+	n, err := r.reader.Read(b)
+	if n <= 0 {
+		return n, err
+	}
+	waitErr := doWait(r.limiter, n)
+	if waitErr != nil {
+		return 0, waitErr
+	}
+	return n, err
+}
+
+type limitedWriter struct {
+	writer  io.Writer
+	limiter *rate.Limiter
+}
+
+func (w *limitedWriter) Write(b []byte) (int, error) {
+	n, err := w.writer.Write(b)
+	if n <= 0 {
+		return n, err
+	}
+	waitErr := doWait(w.limiter, n)
+	if waitErr != nil {
+		return 0, waitErr
+	}
+	return n, err
+}
+
+func createLimiter(limit int) *rate.Limiter {
+	burst := limit
+	theRate := rate.Every(time.Second) * rate.Limit(burst)
+	return rate.NewLimiter(theRate, burst)
+}
+
+func (l *trafficLimiter) WrapReaderWriter(accessKey string, reader io.Reader, writer io.Writer) (io.Reader, io.Writer) {
+	limiter, ok := l.keyToLimiter[accessKey]
+	if !ok {
+		logger.Panicf("Access key %v not found", accessKey)
+	}
+	if limiter == nil {
+		return reader, writer
+	}
+	return &limitedReader{reader: reader, limiter: limiter}, &limitedWriter{writer: writer, limiter: limiter}
+}
+
+func (l *trafficLimiter) Allow(accessKey string, n int) bool {
+	limiter, ok := l.keyToLimiter[accessKey]
+	if !ok {
+		logger.Panicf("Access key %v not found", accessKey)
+	}
+	if limiter == nil {
+		return true
+	}
+	return limiter.AllowN(time.Now(), n)
+}
diff --git a/service/limiter_test.go b/service/limiter_test.go
new file mode 100644
index 0000000..e27eaa8
--- /dev/null
+++ b/service/limiter_test.go
@@ -0,0 +1,121 @@
+// Copyright 2020 Jigsaw Operations LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package service
+
+import (
+	"bytes"
+	"io"
+	"math/rand"
+	"testing"
+	"time"
+
+	"github.com/stretchr/testify/require"
+)
+
+func makeRandBuffer(n int64) *bytes.Buffer {
+	arr := make([]byte, n)
+	rand.Read(arr)
+	return bytes.NewBuffer(arr)
+}
+
+func TestTrafficLimiter(t *testing.T) {
+	key1 := "key1"
+	key2 := "key2"
+	key3 := "key3"
+
+	config := TrafficLimiterConfig{
+		KeyToRateLimit: map[string]int{
+			key1: 20,
+			key2: 30,
+			key3: 0,
+		},
+	}
+
+	limiter := NewTrafficLimiter(&config)
+
+	src1Buf := makeRandBuffer(100)
+	src1 := src1Buf.Bytes()
+	dst1 := &bytes.Buffer{}
+
+	src2Buf := makeRandBuffer(100)
+	src2 := src2Buf.Bytes()
+	dst2 := &bytes.Buffer{}
+
+	src3Buf := makeRandBuffer(100)
+	src3 := src3Buf.Bytes()
+	dst3 := &bytes.Buffer{}
+
+	r1, w1 := limiter.WrapReaderWriter(key1, src1Buf, dst1)
+	r2, w2 := limiter.WrapReaderWriter(key2, src2Buf, dst2)
+	r3, w3 := limiter.WrapReaderWriter(key3, src3Buf, dst3)
+
+	doRead := func(buf []byte, r io.Reader, n int) time.Duration {
+		b := make([]byte, n)
+		start := time.Now()
+		_, err := io.ReadFull(r, b)
+		require.NoError(t, err)
+		require.Equal(t, b, buf[:len(b)])
+		return time.Now().Sub(start)
+	}
+
+	period1 := doRead(src1, r1, 20)
+	if period1 > 10*time.Millisecond {
+		t.Errorf("read took too long")
+	}
+
+	period2 := doRead(src2, r2, 30)
+	if period2 > 10*time.Millisecond {
+		t.Errorf("read took too long")
+	}
+
+	period3 := doRead(src3, r3, 100)
+	if period3 > 10*time.Millisecond {
+		t.Errorf("read took too long")
+	}
+
+	doWrite := func(buf []byte, dst *bytes.Buffer, w io.Writer) time.Duration {
+		start := time.Now()
+		size := len(buf)
+		_, err := w.Write(buf)
+		require.NoError(t, err)
+		require.Equal(t, buf, dst.Bytes()[:size])
+		return time.Now().Sub(start)
+	}
+
+	// Waiting works even for payload exceeding one second burst.
+	period4 := doWrite(src1[:30], dst1, w1)
+	if period4 < 500*time.Millisecond {
+		t.Fatalf("write took too short")
+	}
+
+	allowed := limiter.Allow(key2, 30)
+	require.True(t, allowed)
+
+	allowed = limiter.Allow(key2, 10)
+	require.False(t, allowed)
+
+	period5 := doWrite(src2[:30], dst2, w2)
+	if period5 < 500*time.Millisecond {
+		t.Fatalf("write took too short")
+	}
+
+	allowed = limiter.Allow(key3, 1000)
+	require.True(t, allowed)
+
+	period6 := doWrite(src3[:100], dst3, w3)
+	if period6 > 10*time.Millisecond {
+		t.Fatalf("write took too long")
+	}
+}
diff --git a/service/limiter_testing.go b/service/limiter_testing.go
new file mode 100644
index 0000000..081d7a2
--- /dev/null
+++ b/service/limiter_testing.go
@@ -0,0 +1,29 @@
+// Copyright 2018 Jigsaw Operations LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package service
+
+import (
+	"net"
+)
+
+func MakeTestTrafficLimiterConfig(ciphers CipherList) TrafficLimiterConfig {
+	elts := ciphers.SnapshotForClientIP(net.IP{})
+	keyToLimit := make(map[string]int)
+	for _, elt := range elts {
+		entry := elt.Value.(*CipherEntry)
+		keyToLimit[entry.ID] = 0
+	}
+	return TrafficLimiterConfig{KeyToRateLimit: keyToLimit}
+}
diff --git a/service/tcp.go b/service/tcp.go
index d295931..cfd68fc 100644
--- a/service/tcp.go
+++ b/service/tcp.go
@@ -126,16 +126,20 @@ type tcpHandler struct {
 	// `replayCache` is a pointer to SSServer.replayCache, to share the cache among all ports.
 	replayCache       *ReplayCache
 	targetIPValidator onet.TargetIPValidator
+	limiter           TrafficLimiter
 }
 
 // NewTCPService creates a TCPService
 // `replayCache` is a pointer to SSServer.replayCache, to share the cache among all ports.
-func NewTCPHandler(port int, ciphers CipherList, replayCache *ReplayCache, m TCPMetrics, timeout time.Duration) TCPHandler {
+func NewTCPHandler(port int, ciphers CipherList, replayCache *ReplayCache, m TCPMetrics,
+	timeout time.Duration, limiter TrafficLimiter,
+) TCPHandler {
 	return &tcpHandler{
 		port:              port,
 		ciphers:           ciphers,
 		m:                 m,
 		readTimeout:       timeout,
+		limiter:           limiter,
 		replayCache:       replayCache,
 		targetIPValidator: onet.RequirePublicIP,
 	}
@@ -252,9 +256,15 @@ func (h *tcpHandler) handleConnection(listenerPort int, clientConn transport.Str
 		h.absorbProbe(listenerPort, clientConn, status, proxyMetrics)
 		return "", onet.NewConnectionError(status, "Failed to find a valid cipher", keyErr)
 	}
-	var id string
+	var (
+		id           string
+		accessKey    string
+		clientWriter io.Writer = clientConn
+	)
 	if cipherEntry != nil {
 		id = cipherEntry.ID
+		accessKey = cipherEntry.ID
+		clientReader, clientWriter = h.limiter.WrapReaderWriter(accessKey, clientReader, clientWriter)
 	}
 
 	// 2. Check if the connection is a replay.
@@ -279,9 +289,10 @@ func (h *tcpHandler) handleConnection(listenerPort int, clientConn transport.Str
 	clientConn.SetReadDeadline(time.Time{})
 	if err != nil {
 		// Drain to prevent a close on cipher error.
-		io.Copy(io.Discard, clientConn)
+		io.Copy(io.Discard, clientReader)
 		return id, onet.NewConnectionError("ERR_READ_ADDRESS", "Failed to get target address", err)
 	}
+	logger.Debugf("address %s", clientConn.RemoteAddr().String())
 	tgtConn, dialErr := dialTarget(tgtAddr, proxyMetrics, h.targetIPValidator)
 	if dialErr != nil {
 		// We don't drain so dial errors and invalid addresses are communicated quickly.
@@ -291,15 +302,16 @@ func (h *tcpHandler) handleConnection(listenerPort int, clientConn transport.Str
 
 	// 4. Bridge the client and target connections
 	logger.Debugf("proxy %s <-> %s", clientConn.RemoteAddr().String(), tgtConn.RemoteAddr().String())
-	ssw := shadowsocks.NewWriter(clientConn, cipherEntry.CryptoKey)
+	ssw := shadowsocks.NewWriter(clientWriter, cipherEntry.CryptoKey)
 	ssw.SetSaltGenerator(cipherEntry.SaltGenerator)
 
 	fromClientErrCh := make(chan error)
 	go func() {
 		_, fromClientErr := ssr.WriteTo(tgtConn)
+		logger.Debugf("fromClientErr: %v", fromClientErr)
 		if fromClientErr != nil {
 			// Drain to prevent a close in the case of a cipher error.
-			io.Copy(io.Discard, clientConn)
+			io.Copy(io.Discard, clientReader)
 		}
 		clientConn.CloseRead()
 		// Send FIN to target.
@@ -353,6 +365,7 @@ var _ TCPMetrics = (*NoOpTCPMetrics)(nil)
 
 func (m *NoOpTCPMetrics) AddClosedTCPConnection(clientInfo ipinfo.IPInfo, accessKey, status string, data metrics.ProxyMetrics, duration time.Duration) {
 }
+
 func (m *NoOpTCPMetrics) GetIPInfo(net.IP) (ipinfo.IPInfo, error) {
 	return ipinfo.IPInfo{}, nil
 }
diff --git a/service/tcp_test.go b/service/tcp_test.go
index 1f38111..5274f32 100644
--- a/service/tcp_test.go
+++ b/service/tcp_test.go
@@ -233,8 +233,10 @@ func (m *probeTestMetrics) AddClosedTCPConnection(clientInfo ipinfo.IPInfo, acce
 func (m *probeTestMetrics) GetIPInfo(net.IP) (ipinfo.IPInfo, error) {
 	return ipinfo.IPInfo{}, nil
 }
+
 func (m *probeTestMetrics) AddOpenTCPConnection(clientInfo ipinfo.IPInfo) {
 }
+
 func (m *probeTestMetrics) AddTCPProbe(status, drainResult string, port int, clientProxyBytes int64) {
 	m.mu.Lock()
 	m.probeData = append(m.probeData, clientProxyBytes)
@@ -271,12 +273,17 @@ func probe(serverAddr *net.TCPAddr, bytesToSend []byte) error {
 	return nil
 }
 
+func makeLimiter(cipherList CipherList) TrafficLimiter {
+	c := MakeTestTrafficLimiterConfig(cipherList)
+	return NewTrafficLimiter(&c)
+}
+
 func TestProbeRandom(t *testing.T) {
 	listener := makeLocalhostListener(t)
 	cipherList, err := MakeTestCiphers(makeTestSecrets(1))
 	require.NoError(t, err, "MakeTestCiphers failed: %v", err)
 	testMetrics := &probeTestMetrics{}
-	handler := NewTCPHandler(listener.Addr().(*net.TCPAddr).Port, cipherList, nil, testMetrics, 200*time.Millisecond)
+	handler := NewTCPHandler(listener.Addr().(*net.TCPAddr).Port, cipherList, nil, testMetrics, 200*time.Millisecond, makeLimiter(cipherList))
 	done := make(chan struct{})
 	go func() {
 		StreamServe(WrapStreamListener(listener.AcceptTCP), handler.Handle)
@@ -352,7 +359,7 @@ func TestProbeClientBytesBasicTruncated(t *testing.T) {
 	require.NoError(t, err, "MakeTestCiphers failed: %v", err)
 	cipher := firstCipher(cipherList)
 	testMetrics := &probeTestMetrics{}
-	handler := NewTCPHandler(listener.Addr().(*net.TCPAddr).Port, cipherList, nil, testMetrics, 200*time.Millisecond)
+	handler := NewTCPHandler(listener.Addr().(*net.TCPAddr).Port, cipherList, nil, testMetrics, 200*time.Millisecond, makeLimiter(cipherList))
 	handler.SetTargetIPValidator(allowAll)
 	done := make(chan struct{})
 	go func() {
@@ -387,7 +394,7 @@ func TestProbeClientBytesBasicModified(t *testing.T) {
 	require.NoError(t, err, "MakeTestCiphers failed: %v", err)
 	cipher := firstCipher(cipherList)
 	testMetrics := &probeTestMetrics{}
-	handler := NewTCPHandler(listener.Addr().(*net.TCPAddr).Port, cipherList, nil, testMetrics, 200*time.Millisecond)
+	handler := NewTCPHandler(listener.Addr().(*net.TCPAddr).Port, cipherList, nil, testMetrics, 200*time.Millisecond, makeLimiter(cipherList))
 	handler.SetTargetIPValidator(allowAll)
 	done := make(chan struct{})
 	go func() {
@@ -423,7 +430,7 @@ func TestProbeClientBytesCoalescedModified(t *testing.T) {
 	require.NoError(t, err, "MakeTestCiphers failed: %v", err)
 	cipher := firstCipher(cipherList)
 	testMetrics := &probeTestMetrics{}
-	handler := NewTCPHandler(listener.Addr().(*net.TCPAddr).Port, cipherList, nil, testMetrics, 200*time.Millisecond)
+	handler := NewTCPHandler(listener.Addr().(*net.TCPAddr).Port, cipherList, nil, testMetrics, 200*time.Millisecond, makeLimiter(cipherList))
 	handler.SetTargetIPValidator(allowAll)
 	done := make(chan struct{})
 	go func() {
@@ -466,7 +473,7 @@ func TestProbeServerBytesModified(t *testing.T) {
 	require.NoError(t, err, "MakeTestCiphers failed: %v", err)
 	cipher := firstCipher(cipherList)
 	testMetrics := &probeTestMetrics{}
-	handler := NewTCPHandler(listener.Addr().(*net.TCPAddr).Port, cipherList, nil, testMetrics, 200*time.Millisecond)
+	handler := NewTCPHandler(listener.Addr().(*net.TCPAddr).Port, cipherList, nil, testMetrics, 200*time.Millisecond, makeLimiter(cipherList))
 	done := make(chan struct{})
 	go func() {
 		StreamServe(WrapStreamListener(listener.AcceptTCP), handler.Handle)
@@ -496,7 +503,7 @@ func TestReplayDefense(t *testing.T) {
 	replayCache := NewReplayCache(5)
 	testMetrics := &probeTestMetrics{}
 	const testTimeout = 200 * time.Millisecond
-	handler := NewTCPHandler(listener.Addr().(*net.TCPAddr).Port, cipherList, &replayCache, testMetrics, testTimeout)
+	handler := NewTCPHandler(listener.Addr().(*net.TCPAddr).Port, cipherList, &replayCache, testMetrics, testTimeout, makeLimiter(cipherList))
 	snapshot := cipherList.SnapshotForClientIP(nil)
 	cipherEntry := snapshot[0].Value.(*CipherEntry)
 	cipher := cipherEntry.CryptoKey
@@ -574,7 +581,7 @@ func TestReverseReplayDefense(t *testing.T) {
 	replayCache := NewReplayCache(5)
 	testMetrics := &probeTestMetrics{}
 	const testTimeout = 200 * time.Millisecond
-	handler := NewTCPHandler(listener.Addr().(*net.TCPAddr).Port, cipherList, &replayCache, testMetrics, testTimeout)
+	handler := NewTCPHandler(listener.Addr().(*net.TCPAddr).Port, cipherList, &replayCache, testMetrics, testTimeout, makeLimiter(cipherList))
 	snapshot := cipherList.SnapshotForClientIP(nil)
 	cipherEntry := snapshot[0].Value.(*CipherEntry)
 	cipher := cipherEntry.CryptoKey
@@ -644,7 +651,7 @@ func probeExpectTimeout(t *testing.T, payloadSize int) {
 	cipherList, err := MakeTestCiphers(makeTestSecrets(5))
 	require.NoError(t, err, "MakeTestCiphers failed: %v", err)
 	testMetrics := &probeTestMetrics{}
-	handler := NewTCPHandler(listener.Addr().(*net.TCPAddr).Port, cipherList, nil, testMetrics, testTimeout)
+	handler := NewTCPHandler(listener.Addr().(*net.TCPAddr).Port, cipherList, nil, testMetrics, testTimeout, makeLimiter(cipherList))
 
 	done := make(chan struct{})
 	go func() {
diff --git a/service/udp.go b/service/udp.go
index 4138ed8..3918e25 100644
--- a/service/udp.go
+++ b/service/udp.go
@@ -88,11 +88,18 @@ type packetHandler struct {
 	ciphers           CipherList
 	m                 UDPMetrics
 	targetIPValidator onet.TargetIPValidator
+	limiter           TrafficLimiter
 }
 
 // NewPacketHandler creates a UDPService
-func NewPacketHandler(natTimeout time.Duration, cipherList CipherList, m UDPMetrics) PacketHandler {
-	return &packetHandler{natTimeout: natTimeout, ciphers: cipherList, m: m, targetIPValidator: onet.RequirePublicIP}
+func NewPacketHandler(natTimeout time.Duration, cipherList CipherList, m UDPMetrics, limiter TrafficLimiter) PacketHandler {
+	return &packetHandler{
+		natTimeout:        natTimeout,
+		ciphers:           cipherList,
+		m:                 m,
+		targetIPValidator: onet.RequirePublicIP,
+		limiter:           limiter,
+	}
 }
 
 // PacketHandler is a running UDP shadowsocks proxy that can be stopped.
@@ -112,7 +119,7 @@ func (h *packetHandler) SetTargetIPValidator(targetIPValidator onet.TargetIPVali
 func (h *packetHandler) Handle(clientConn net.PacketConn) {
 	var running sync.WaitGroup
 
-	nm := newNATmap(h.natTimeout, h.m, &running)
+	nm := newNATmap(h.natTimeout, h.m, &running, h.limiter)
 	defer nm.Close()
 	cipherBuf := make([]byte, serverUDPBufferSize)
 	textBuf := make([]byte, serverUDPBufferSize)
@@ -200,6 +207,11 @@ func (h *packetHandler) Handle(clientConn net.PacketConn) {
 			}
 
 			debugUDPAddr(clientAddr, "Proxy exit %v", targetConn.LocalAddr())
+			allowed := h.limiter.Allow(keyID, len(payload))
+			if !allowed {
+				debugUDPAddr(clientAddr, "Rate limite exceeded, dropping packet from client (len %v)", len(payload))
+				return onet.NewConnectionError("ERR_LIMIT", "Rate limit exceeded", nil)
+			}
 			proxyTargetBytes, err = targetConn.WriteTo(payload, tgtUDPAddr) // accept only UDPAddr despite the signature
 			if err != nil {
 				return onet.NewConnectionError("ERR_WRITE", "Failed to write to target", err)
@@ -311,10 +323,11 @@ type natmap struct {
 	timeout time.Duration
 	metrics UDPMetrics
 	running *sync.WaitGroup
+	limiter TrafficLimiter
 }
 
-func newNATmap(timeout time.Duration, sm UDPMetrics, running *sync.WaitGroup) *natmap {
-	m := &natmap{metrics: sm, running: running}
+func newNATmap(timeout time.Duration, sm UDPMetrics, running *sync.WaitGroup, limiter TrafficLimiter) *natmap {
+	m := &natmap{metrics: sm, running: running, limiter: limiter}
 	m.keyConn = make(map[string]*natconn)
 	m.timeout = timeout
 	return m
@@ -360,7 +373,7 @@ func (m *natmap) Add(clientAddr net.Addr, clientConn net.PacketConn, cryptoKey *
 	m.metrics.AddUDPNatEntry()
 	m.running.Add(1)
 	go func() {
-		timedCopy(clientAddr, clientConn, entry, keyID, m.metrics)
+		timedCopy(clientAddr, clientConn, entry, keyID, m.metrics, m.limiter)
 		m.metrics.RemoveUDPNatEntry()
 		if pc := m.del(clientAddr.String()); pc != nil {
 			pc.Close()
@@ -390,7 +403,8 @@ var maxAddrLen int = len(socks.ParseAddr("[2001:db8::1]:12345"))
 
 // copy from target to client until read timeout
 func timedCopy(clientAddr net.Addr, clientConn net.PacketConn, targetConn *natconn,
-	keyID string, sm UDPMetrics) {
+	keyID string, sm UDPMetrics, limiter TrafficLimiter,
+) {
 	// pkt is used for in-place encryption of downstream UDP packets, with the layout
 	// [padding?][salt][address][body][tag][extra]
 	// Padding is only used if the address is IPv4.
@@ -424,6 +438,13 @@ func timedCopy(clientAddr net.Addr, clientConn net.PacketConn, targetConn *natco
 			}
 
 			debugUDPAddr(clientAddr, "Got response from %v", raddr)
+
+			allowed := limiter.Allow(keyID, bodyLen)
+			if !allowed {
+				debugUDPAddr(clientAddr, "Rate limite exceeded, dropping packet to client (len %v)", bodyLen)
+				return onet.NewConnectionError("ERR_LIMIT", "Rate limit exceeded", nil)
+			}
+
 			srcAddr := socks.ParseAddr(raddr.String())
 			addrStart := bodyStart - len(srcAddr)
 			// `plainTextBuf` concatenates the SOCKS address and body:
@@ -471,8 +492,10 @@ var _ UDPMetrics = (*NoOpUDPMetrics)(nil)
 func (m *NoOpUDPMetrics) GetIPInfo(net.IP) (ipinfo.IPInfo, error) {
 	return ipinfo.IPInfo{}, nil
 }
+
 func (m *NoOpUDPMetrics) AddUDPPacketFromClient(clientInfo ipinfo.IPInfo, accessKey, status string, clientProxyBytes, proxyTargetBytes int) {
 }
+
 func (m *NoOpUDPMetrics) AddUDPPacketFromTarget(clientInfo ipinfo.IPInfo, accessKey, status string, targetProxyBytes, proxyClientBytes int) {
 }
 func (m *NoOpUDPMetrics) AddUDPNatEntry()                                                    {}
diff --git a/service/udp_test.go b/service/udp_test.go
index 27756e3..bd53126 100644
--- a/service/udp_test.go
+++ b/service/udp_test.go
@@ -25,6 +25,7 @@ import (
 	"github.com/Jigsaw-Code/outline-sdk/transport/shadowsocks"
 	"github.com/Jigsaw-Code/outline-ss-server/ipinfo"
 	onet "github.com/Jigsaw-Code/outline-ss-server/net"
+	ss "github.com/Jigsaw-Code/outline-ss-server/shadowsocks"
 	logging "github.com/op/go-logging"
 	"github.com/shadowsocks/go-shadowsocks2/socks"
 	"github.com/stretchr/testify/assert"
@@ -33,10 +34,12 @@ import (
 
 const timeout = 5 * time.Minute
 
-var clientAddr = net.UDPAddr{IP: []byte{192, 0, 2, 1}, Port: 12345}
-var targetAddr = net.UDPAddr{IP: []byte{192, 0, 2, 2}, Port: 54321}
-var dnsAddr = net.UDPAddr{IP: []byte{192, 0, 2, 3}, Port: 53}
-var natCryptoKey *shadowsocks.EncryptionKey
+var (
+	clientAddr   = net.UDPAddr{IP: []byte{192, 0, 2, 1}, Port: 12345}
+	targetAddr   = net.UDPAddr{IP: []byte{192, 0, 2, 2}, Port: 54321}
+	dnsAddr      = net.UDPAddr{IP: []byte{192, 0, 2, 3}, Port: 53}
+	natCryptoKey *shadowsocks.EncryptionKey
+)
 
 func init() {
 	logging.SetLevel(logging.INFO, "")
@@ -108,11 +111,14 @@ var _ UDPMetrics = (*natTestMetrics)(nil)
 func (m *natTestMetrics) GetIPInfo(net.IP) (ipinfo.IPInfo, error) {
 	return ipinfo.IPInfo{}, nil
 }
+
 func (m *natTestMetrics) AddUDPPacketFromClient(clientInfo ipinfo.IPInfo, accessKey, status string, clientProxyBytes, proxyTargetBytes int) {
 	m.upstreamPackets = append(m.upstreamPackets, udpReport{clientInfo, accessKey, status, clientProxyBytes, proxyTargetBytes})
 }
+
 func (m *natTestMetrics) AddUDPPacketFromTarget(clientInfo ipinfo.IPInfo, accessKey, status string, targetProxyBytes, proxyClientBytes int) {
 }
+
 func (m *natTestMetrics) AddUDPNatEntry() {
 	m.natEntriesAdded++
 }
@@ -126,7 +132,7 @@ func sendToDiscard(payloads [][]byte, validator onet.TargetIPValidator) *natTest
 	cipher := ciphers.SnapshotForClientIP(nil)[0].Value.(*CipherEntry).CryptoKey
 	clientConn := makePacketConn()
 	metrics := &natTestMetrics{}
-	handler := NewPacketHandler(timeout, ciphers, metrics)
+	handler := NewPacketHandler(timeout, ciphers, metrics, makeLimiter(ciphers))
 	handler.SetTargetIPValidator(validator)
 	done := make(chan struct{})
 	go func() {
@@ -203,17 +209,26 @@ func assertAlmostEqual(t *testing.T, a, b time.Time) {
 }
 
 func TestNATEmpty(t *testing.T) {
-	nat := newNATmap(timeout, &natTestMetrics{}, &sync.WaitGroup{})
+	cipherList, err := MakeTestCiphers(ss.MakeTestSecrets(1))
+	if err != nil {
+		logger.Fatal(err)
+	}
+	nat := newNATmap(timeout, &natTestMetrics{}, &sync.WaitGroup{}, makeLimiter(cipherList))
 	if nat.Get("foo") != nil {
 		t.Error("Expected nil value from empty NAT map")
 	}
 }
 
 func setupNAT() (*fakePacketConn, *fakePacketConn, *natconn) {
-	nat := newNATmap(timeout, &natTestMetrics{}, &sync.WaitGroup{})
+	cipherList, err := MakeTestCiphers(ss.MakeTestSecrets(1))
+	if err != nil {
+		logger.Fatal(err)
+	}
+	nat := newNATmap(timeout, &natTestMetrics{}, &sync.WaitGroup{}, makeLimiter(cipherList))
 	clientConn := makePacketConn()
 	targetConn := makePacketConn()
-	nat.Add(&clientAddr, clientConn, natCryptoKey, targetConn, ipinfo.IPInfo{CountryCode: "ZZ"}, "key id")
+	key := cipherList.SnapshotForClientIP(net.IP{})[0].Value.(*CipherEntry).ID
+	nat.Add(&clientAddr, clientConn, natCryptoKey, targetConn, ipinfo.IPInfo{CountryCode: "ZZ"}, key)
 	entry := nat.Get(clientAddr.String())
 	return clientConn, targetConn, entry
 }
@@ -478,7 +493,7 @@ func TestUDPEarlyClose(t *testing.T) {
 	}
 	testMetrics := &natTestMetrics{}
 	const testTimeout = 200 * time.Millisecond
-	s := NewPacketHandler(testTimeout, cipherList, testMetrics)
+	s := NewPacketHandler(testTimeout, cipherList, testMetrics, makeLimiter(cipherList))
 
 	clientConn, err := net.ListenUDP("udp", &net.UDPAddr{IP: net.ParseIP("127.0.0.1"), Port: 0})
 	if err != nil {
