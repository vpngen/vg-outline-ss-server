diff --git a/cmd/outline-ss-server/config_example.yml b/cmd/outline-ss-server/config_example.yml
index 8895b86..aa4c56c 100644
--- a/cmd/outline-ss-server/config_example.yml
+++ b/cmd/outline-ss-server/config_example.yml
@@ -1,15 +1,22 @@
+bind_address: "127.0.0.1"
 keys:
   - id: user-0
     port: 9000
     cipher: chacha20-ietf-poly1305
     secret: Secret0
+    recv_limit: 128000
+    send_limit: 128000
 
   - id: user-1
     port: 9000
     cipher: chacha20-ietf-poly1305
     secret: Secret1
+    recv_limit: 128000
+    send_limit: 128000
 
   - id: user-2
     port: 9001
     cipher: chacha20-ietf-poly1305
     secret: Secret2
+    recv_limit: 128000
+    send_limit: 128000
diff --git a/cmd/outline-ss-server/main.go b/cmd/outline-ss-server/main.go
index 748003e..b1d3a60 100644
--- a/cmd/outline-ss-server/main.go
+++ b/cmd/outline-ss-server/main.go
@@ -49,7 +49,7 @@ const tcpReadTimeout time.Duration = 59 * time.Second
 const defaultNatTimeout time.Duration = 5 * time.Minute
 
 func init() {
-	var prefix = "%{level:.1s}%{time:2006-01-02T15:04:05.000Z07:00} %{pid} %{shortfile}]"
+	prefix := "%{level:.1s}%{time:2006-01-02T15:04:05.000Z07:00} %{pid} %{shortfile}]"
 	if term.IsTerminal(int(os.Stderr.Fd())) {
 		// Add color only if the output is the terminal
 		prefix = strings.Join([]string{"%{color}", prefix, "%{color:reset}"}, "")
@@ -72,14 +72,15 @@ type SSServer struct {
 	ports       map[int]*ssPort
 }
 
-func (s *SSServer) startPort(portNum int) error {
-	listener, err := net.ListenTCP("tcp", &net.TCPAddr{Port: portNum})
+func (s *SSServer) startPort(portNum int, ipAddr string) error {
+	listenIP := net.ParseIP(ipAddr)
+	listener, err := net.ListenTCP("tcp", &net.TCPAddr{Port: portNum, IP: listenIP})
 	if err != nil {
 		//lint:ignore ST1005 Shadowsocks is capitalized.
 		return fmt.Errorf("Shadowsocks TCP service failed to start on port %v: %w", portNum, err)
 	}
 	logger.Infof("Shadowsocks TCP service listening on %v", listener.Addr().String())
-	packetConn, err := net.ListenUDP("udp", &net.UDPAddr{Port: portNum})
+	packetConn, err := net.ListenUDP("udp", &net.UDPAddr{Port: portNum, IP: listenIP})
 	if err != nil {
 		//lint:ignore ST1005 Shadowsocks is capitalized.
 		return fmt.Errorf("Shadowsocks UDP service failed to start on port %v: %w", portNum, err)
@@ -123,12 +124,18 @@ func (s *SSServer) removePort(portNum int) error {
 	return nil
 }
 
-func (s *SSServer) loadConfig(filename string) error {
+func (s *SSServer) loadConfig(filename string, bindAddrForOverwrite string) error {
 	config, err := readConfig(filename)
 	if err != nil {
 		return fmt.Errorf("failed to load config (%v): %w", filename, err)
 	}
 
+	bindAddr := config.BindAddress
+	// Overwrite config file
+	if bindAddrForOverwrite != "" {
+		bindAddr = bindAddrForOverwrite
+	}
+
 	portChanges := make(map[int]int)
 	portCiphers := make(map[int]*list.List) // Values are *List of *CipherEntry.
 	for _, keyConfig := range config.Keys {
@@ -142,7 +149,8 @@ func (s *SSServer) loadConfig(filename string) error {
 		if err != nil {
 			return fmt.Errorf("failed to create encyption key for key %v: %w", keyConfig.ID, err)
 		}
-		entry := service.MakeCipherEntry(keyConfig.ID, cryptoKey, keyConfig.Secret)
+		entry := service.MakeCipherEntry(keyConfig.ID, cryptoKey, keyConfig.Secret,
+			service.NewTrafficLimiter(keyConfig.RecvLimit, keyConfig.SendLimit))
 		cipherList.PushBack(&entry)
 	}
 	for port := range s.ports {
@@ -154,7 +162,7 @@ func (s *SSServer) loadConfig(filename string) error {
 				return fmt.Errorf("failed to remove port %v: %w", portNum, err)
 			}
 		} else if count == +1 {
-			if err := s.startPort(portNum); err != nil {
+			if err := s.startPort(portNum, bindAddr); err != nil {
 				return err
 			}
 		}
@@ -178,14 +186,16 @@ func (s *SSServer) Stop() error {
 }
 
 // RunSSServer starts a shadowsocks server running, and returns the server or an error.
-func RunSSServer(filename string, natTimeout time.Duration, sm *outlineMetrics, replayHistory int) (*SSServer, error) {
+func RunSSServer(filename string, natTimeout time.Duration, sm *outlineMetrics, replayHistory int,
+	bindAddr string,
+) (*SSServer, error) {
 	server := &SSServer{
 		natTimeout:  natTimeout,
 		m:           sm,
 		replayCache: service.NewReplayCache(replayHistory),
 		ports:       make(map[int]*ssPort),
 	}
-	err := server.loadConfig(filename)
+	err := server.loadConfig(filename, bindAddr)
 	if err != nil {
 		return nil, fmt.Errorf("failed configure server: %w", err)
 	}
@@ -194,7 +204,7 @@ func RunSSServer(filename string, natTimeout time.Duration, sm *outlineMetrics,
 	go func() {
 		for range sigHup {
 			logger.Infof("SIGHUP received. Loading config from %v", filename)
-			if err := server.loadConfig(filename); err != nil {
+			if err := server.loadConfig(filename, bindAddr); err != nil {
 				logger.Errorf("Failed to update server: %v. Server state may be invalid. Fix the error and try the update again", err)
 			}
 		}
@@ -203,12 +213,15 @@ func RunSSServer(filename string, natTimeout time.Duration, sm *outlineMetrics,
 }
 
 type Config struct {
-	Keys []struct {
-		ID     string
-		Port   int
-		Cipher string
-		Secret string
-	}
+	BindAddress string `yaml:"bind_address"`
+	Keys        []struct {
+		ID        string `yaml:"id"`
+		Port      int    `yaml:"port"`
+		Cipher    string `yaml:"cipher"`
+		Secret    string `yaml:"secret"`
+		RecvLimit int    `yaml:"recv_limit"`
+		SendLimit int    `yaml:"send_limit"`
+	} `yaml:"keys"`
 }
 
 func readConfig(filename string) (*Config, error) {
@@ -230,6 +243,7 @@ func main() {
 		MetricsAddr   string
 		IPCountryDB   string
 		IPASNDB       string
+		BindAddr      string
 		natTimeout    time.Duration
 		replayHistory int
 		Verbose       bool
@@ -244,6 +258,8 @@ func main() {
 	flag.BoolVar(&flags.Verbose, "verbose", false, "Enables verbose logging output")
 	flag.BoolVar(&flags.Version, "version", false, "The version of the server")
 
+	flag.StringVar(&flags.BindAddr, "bind_addr", "", "IP address to bind to (overwrites config file)")
+
 	flag.Parse()
 
 	if flags.Verbose {
@@ -285,7 +301,7 @@ func main() {
 
 	m := newPrometheusOutlineMetrics(ip2info, prometheus.DefaultRegisterer)
 	m.SetBuildInfo(version)
-	_, err = RunSSServer(flags.ConfigFile, flags.natTimeout, m, flags.replayHistory)
+	_, err = RunSSServer(flags.ConfigFile, flags.natTimeout, m, flags.replayHistory, flags.BindAddr)
 	if err != nil {
 		logger.Fatalf("Server failed to start: %v. Aborting", err)
 	}
diff --git a/cmd/outline-ss-server/server_test.go b/cmd/outline-ss-server/server_test.go
index 0b7777b..e41f693 100644
--- a/cmd/outline-ss-server/server_test.go
+++ b/cmd/outline-ss-server/server_test.go
@@ -23,7 +23,7 @@ import (
 
 func TestRunSSServer(t *testing.T) {
 	m := newPrometheusOutlineMetrics(nil, prometheus.DefaultRegisterer)
-	server, err := RunSSServer("config_example.yml", 30*time.Second, m, 10000)
+	server, err := RunSSServer("config_example.yml", 30*time.Second, m, 10000, "")
 	if err != nil {
 		t.Fatalf("RunSSServer() error = %v", err)
 	}
diff --git a/internal/integration_test/integration_test.go b/internal/integration_test/integration_test.go
index ecb5ee2..a9366c7 100644
--- a/internal/integration_test/integration_test.go
+++ b/internal/integration_test/integration_test.go
@@ -107,7 +107,7 @@ func TestTCPEcho(t *testing.T) {
 		t.Fatalf("ListenTCP failed: %v", err)
 	}
 	secrets := []string{"secret"}
-	cipherList, err := service.MakeTestCiphers(secrets)
+	cipherList, err := service.MakeTestCiphers(secrets, 0, 0)
 	if err != nil {
 		t.Fatal(err)
 	}
@@ -161,6 +161,169 @@ func TestTCPEcho(t *testing.T) {
 	echoRunning.Wait()
 }
 
+func TestTrafficLimiterTCP(t *testing.T) {
+	echoListener, echoRunning := startTCPEchoServer(t)
+
+	proxyListener, err := net.ListenTCP("tcp", &net.TCPAddr{IP: net.ParseIP("127.0.0.1"), Port: 0})
+	if err != nil {
+		t.Fatalf("ListenTCP failed: %v", err)
+	}
+	secrets := sstest.MakeTestSecrets(1)
+	cipherList, err := service.MakeTestCiphers(secrets, 1000, 1000)
+	if err != nil {
+		t.Fatal(err)
+	}
+	replayCache := service.NewReplayCache(5)
+	const testTimeout = 5 * time.Second
+
+	handler := service.NewTCPHandler(proxyListener.Addr().(*net.TCPAddr).Port, cipherList, &replayCache, &service.NoOpTCPMetrics{}, testTimeout)
+	handler.SetTargetIPValidator(allowAll)
+	done := make(chan struct{})
+	go func() {
+		service.StreamServe(func() (transport.StreamConn, error) { return proxyListener.AcceptTCP() }, handler.Handle)
+		done <- struct{}{}
+	}()
+
+	cryptoKey, err := shadowsocks.NewEncryptionKey(shadowsocks.CHACHA20IETFPOLY1305, secrets[0])
+	require.NoError(t, err)
+	client, err := shadowsocks.NewStreamDialer(&transport.TCPEndpoint{Address: proxyListener.Addr().String()}, cryptoKey)
+	require.NoError(t, err)
+
+	doWriteRead := func(N int, repeats int) time.Duration {
+		up := sstest.MakeTestPayload(N)
+		conn, err := client.Dial(context.Background(), echoListener.Addr().String())
+		require.NoError(t, err)
+
+		defer conn.Close()
+
+		start := time.Now()
+		down := make([]byte, N)
+
+		for i := 0; i < repeats; i++ {
+			n, err := conn.Write(up)
+			if err != nil {
+				t.Fatal(err)
+			}
+			if n != N {
+				t.Fatalf("Tried to upload %d bytes, but only sent %d", N, n)
+			}
+
+			n, err = io.ReadFull(conn, down)
+			if err != nil && err != io.EOF {
+				t.Fatal(err)
+			}
+			if n != N {
+				t.Fatalf("Expected to download %d bytes, but only received %d", N, n)
+			}
+
+			if !bytes.Equal(up, down) {
+				t.Fatal("Echo mismatch")
+			}
+		}
+
+		return time.Now().Sub(start)
+	}
+
+	period1 := doWriteRead(200, 4)
+	if period1 < 500*time.Millisecond {
+		t.Fatalf("Write-read loop is too fast")
+	}
+	time.Sleep(1 * time.Second)
+
+	period2 := doWriteRead(200, 2)
+	if period2 > 100*time.Millisecond {
+		t.Fatalf("Write-read loop is too slow")
+	}
+
+	period3 := doWriteRead(500, 2)
+	if period3 < 500*time.Millisecond {
+		t.Fatalf("Write-read loop is too fast")
+	}
+
+	proxyListener.Close()
+	<-done
+	echoListener.Close()
+	echoRunning.Wait()
+}
+
+func TestTrafficLimiterUDP(t *testing.T) {
+	echoConn, echoRunning := startUDPEchoServer(t)
+
+	proxyConn, err := net.ListenUDP("udp", &net.UDPAddr{IP: net.ParseIP("127.0.0.1"), Port: 0})
+	if err != nil {
+		t.Fatalf("ListenTCP failed: %v", err)
+	}
+	secrets := sstest.MakeTestSecrets(1)
+	cipherList, err := service.MakeTestCiphers(secrets, 1000, 1000)
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	testMetrics := &fakeUDPMetrics{}
+	proxy := service.NewPacketHandler(time.Hour, cipherList, testMetrics)
+	proxy.SetTargetIPValidator(allowAll)
+	done := make(chan struct{})
+	go func() {
+		proxy.Handle(proxyConn)
+		done <- struct{}{}
+	}()
+
+	cryptoKey, err := shadowsocks.NewEncryptionKey(shadowsocks.CHACHA20IETFPOLY1305, secrets[0])
+	require.NoError(t, err)
+	client, err := shadowsocks.NewPacketListener(&transport.UDPEndpoint{Address: proxyConn.LocalAddr().String()}, cryptoKey)
+	require.NoError(t, err)
+	conn, err := client.ListenPacket(context.Background())
+	require.NoError(t, err)
+
+	run := func(N int, expectReadError bool) {
+		up := sstest.MakeTestPayload(N)
+		n, err := conn.WriteTo(up, echoConn.LocalAddr())
+		if err != nil {
+			t.Fatal(err)
+		}
+		if n != N {
+			t.Fatalf("Tried to upload %d bytes, but only sent %d", N, n)
+		}
+
+		conn.SetReadDeadline(time.Now().Add(50 * time.Millisecond))
+
+		down := make([]byte, N)
+		n, addr, err := conn.ReadFrom(down)
+		if err != nil {
+			if !expectReadError {
+				t.Fatalf("Unexpected read error: %v", err)
+			}
+			return
+		} else {
+			if expectReadError {
+				t.Fatalf("Expected read error")
+			}
+		}
+		if n != N {
+			t.Fatalf("Tried to download %d bytes, but only sent %d", N, n)
+		}
+		if addr.String() != echoConn.LocalAddr().String() {
+			t.Errorf("Reported address mismatch: %s != %s", addr.String(), echoConn.LocalAddr().String())
+		}
+
+		if !bytes.Equal(up, down) {
+			t.Fatal("Echo mismatch")
+		}
+	}
+
+	for i := 0; i < 3; i++ {
+		run(300, false)
+		run(300, true)
+		time.Sleep(time.Second)
+	}
+
+	conn.Close()
+	echoConn.Close()
+	echoRunning.Wait()
+	proxyConn.Close()
+	<-done
+}
+
 type statusMetrics struct {
 	service.NoOpTCPMetrics
 	sync.Mutex
@@ -177,7 +340,7 @@ func TestRestrictedAddresses(t *testing.T) {
 	proxyListener, err := net.ListenTCP("tcp", &net.TCPAddr{IP: net.ParseIP("127.0.0.1"), Port: 0})
 	require.NoError(t, err, "ListenTCP failed: %v", err)
 	secrets := []string{"secret"}
-	cipherList, err := service.MakeTestCiphers(secrets)
+	cipherList, err := service.MakeTestCiphers(secrets, 0, 0)
 	require.NoError(t, err)
 	const testTimeout = 200 * time.Millisecond
 	testMetrics := &statusMetrics{}
@@ -241,15 +404,19 @@ var _ service.UDPMetrics = (*fakeUDPMetrics)(nil)
 func (m *fakeUDPMetrics) GetIPInfo(ip net.IP) (ipinfo.IPInfo, error) {
 	return ipinfo.IPInfo{CountryCode: "QQ"}, nil
 }
+
 func (m *fakeUDPMetrics) AddUDPPacketFromClient(clientInfo ipinfo.IPInfo, accessKey, status string, clientProxyBytes, proxyTargetBytes int) {
 	m.up = append(m.up, udpRecord{clientInfo, accessKey, status, clientProxyBytes, proxyTargetBytes})
 }
+
 func (m *fakeUDPMetrics) AddUDPPacketFromTarget(clientInfo ipinfo.IPInfo, accessKey, status string, targetProxyBytes, proxyClientBytes int) {
 	m.down = append(m.down, udpRecord{clientInfo, accessKey, status, targetProxyBytes, proxyClientBytes})
 }
+
 func (m *fakeUDPMetrics) AddUDPNatEntry() {
 	m.natAdded++
 }
+
 func (m *fakeUDPMetrics) RemoveUDPNatEntry() {
 	// Not tested because it requires waiting for a long timeout.
 }
@@ -263,7 +430,7 @@ func TestUDPEcho(t *testing.T) {
 		t.Fatalf("ListenTCP failed: %v", err)
 	}
 	secrets := []string{"secret"}
-	cipherList, err := service.MakeTestCiphers(secrets)
+	cipherList, err := service.MakeTestCiphers(secrets, 0, 0)
 	if err != nil {
 		t.Fatal(err)
 	}
@@ -356,7 +523,7 @@ func BenchmarkTCPThroughput(b *testing.B) {
 		b.Fatalf("ListenTCP failed: %v", err)
 	}
 	secrets := []string{"secret"}
-	cipherList, err := service.MakeTestCiphers(secrets)
+	cipherList, err := service.MakeTestCiphers(secrets, 0, 0)
 	if err != nil {
 		b.Fatal(err)
 	}
@@ -417,7 +584,7 @@ func BenchmarkTCPMultiplexing(b *testing.B) {
 	}
 	const numKeys = 50
 	secrets := sstest.MakeTestSecrets(numKeys)
-	cipherList, err := service.MakeTestCiphers(secrets)
+	cipherList, err := service.MakeTestCiphers(secrets, 0, 0)
 	if err != nil {
 		b.Fatal(err)
 	}
@@ -492,7 +659,7 @@ func BenchmarkUDPEcho(b *testing.B) {
 		b.Fatalf("ListenTCP failed: %v", err)
 	}
 	secrets := []string{"secret"}
-	cipherList, err := service.MakeTestCiphers(secrets)
+	cipherList, err := service.MakeTestCiphers(secrets, 0, 0)
 	if err != nil {
 		b.Fatal(err)
 	}
@@ -536,7 +703,7 @@ func BenchmarkUDPManyKeys(b *testing.B) {
 	}
 	const numKeys = 100
 	secrets := sstest.MakeTestSecrets(numKeys)
-	cipherList, err := service.MakeTestCiphers(secrets)
+	cipherList, err := service.MakeTestCiphers(secrets, 0, 0)
 	if err != nil {
 		b.Fatal(err)
 	}
diff --git a/service/cipher_list.go b/service/cipher_list.go
index cadcc40..3794303 100644
--- a/service/cipher_list.go
+++ b/service/cipher_list.go
@@ -28,14 +28,15 @@ const minSaltEntropy = 16
 // CipherEntry holds a Cipher with an identifier.
 // The public fields are constant, but lastClientIP is mutable under cipherList.mu.
 type CipherEntry struct {
-	ID            string
-	CryptoKey     *shadowsocks.EncryptionKey
-	SaltGenerator ServerSaltGenerator
-	lastClientIP  net.IP
+	ID             string
+	CryptoKey      *shadowsocks.EncryptionKey
+	SaltGenerator  ServerSaltGenerator
+	TrafficLimiter TrafficLimiter
+	lastClientIP   net.IP
 }
 
 // MakeCipherEntry constructs a CipherEntry.
-func MakeCipherEntry(id string, cryptoKey *shadowsocks.EncryptionKey, secret string) CipherEntry {
+func MakeCipherEntry(id string, cryptoKey *shadowsocks.EncryptionKey, secret string, limiter TrafficLimiter) CipherEntry {
 	var saltGenerator ServerSaltGenerator
 	if cryptoKey.SaltSize()-serverSaltMarkLen >= minSaltEntropy {
 		// Mark salts with a tag for reverse replay protection.
@@ -46,9 +47,10 @@ func MakeCipherEntry(id string, cryptoKey *shadowsocks.EncryptionKey, secret str
 		saltGenerator = RandomServerSaltGenerator
 	}
 	return CipherEntry{
-		ID:            id,
-		CryptoKey:     cryptoKey,
-		SaltGenerator: saltGenerator,
+		ID:             id,
+		CryptoKey:      cryptoKey,
+		SaltGenerator:  saltGenerator,
+		TrafficLimiter: limiter,
 	}
 }
 
diff --git a/service/cipher_list_test.go b/service/cipher_list_test.go
index 72a852c..11cd1ea 100644
--- a/service/cipher_list_test.go
+++ b/service/cipher_list_test.go
@@ -25,7 +25,7 @@ import (
 func BenchmarkLocking(b *testing.B) {
 	var ip net.IP
 
-	ciphers, _ := MakeTestCiphers([]string{"secret"})
+	ciphers, _ := MakeTestCiphers([]string{"secret"}, 0, 0)
 	b.ResetTimer()
 	b.RunParallel(func(pb *testing.PB) {
 		for pb.Next() {
@@ -41,7 +41,7 @@ func BenchmarkSnapshot(b *testing.B) {
 	// Small cipher lists (N~1e3) fit entirely in cache, and are ~10 times
 	// faster to copy (per entry) than very large cipher lists (N~1e5).
 	const N = 1e3
-	ciphers, _ := MakeTestCiphers(sstest.MakeTestSecrets(N))
+	ciphers, _ := MakeTestCiphers(sstest.MakeTestSecrets(N), 0, 0)
 
 	// Shuffling simulates the behavior of a real server, where successive
 	// ciphers are not expected to be nearby in memory.
diff --git a/service/cipher_list_testing.go b/service/cipher_list_testing.go
index a77427e..dcba9b2 100644
--- a/service/cipher_list_testing.go
+++ b/service/cipher_list_testing.go
@@ -23,7 +23,7 @@ import (
 
 // MakeTestCiphers creates a CipherList containing one fresh AEAD cipher
 // for each secret in `secrets`.
-func MakeTestCiphers(secrets []string) (CipherList, error) {
+func MakeTestCiphers(secrets []string, rx, tx int) (CipherList, error) {
 	l := list.New()
 	for i := 0; i < len(secrets); i++ {
 		cipherID := fmt.Sprintf("id-%v", i)
@@ -31,7 +31,7 @@ func MakeTestCiphers(secrets []string) (CipherList, error) {
 		if err != nil {
 			return nil, fmt.Errorf("failed to create cipher %v: %w", i, err)
 		}
-		entry := MakeCipherEntry(cipherID, cipher, secrets[i])
+		entry := MakeCipherEntry(cipherID, cipher, secrets[i], NewTrafficLimiter(rx, tx))
 		l.PushBack(&entry)
 	}
 	cipherList := NewCipherList()
diff --git a/service/limiter.go b/service/limiter.go
new file mode 100644
index 0000000..5f74d8b
--- /dev/null
+++ b/service/limiter.go
@@ -0,0 +1,132 @@
+// Copyright 2018 Jigsaw Operations LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package service
+
+import (
+	"context"
+	"io"
+	"time"
+
+	"golang.org/x/time/rate"
+)
+
+type TrafficLimiter interface {
+	WrapReaderWriter(reader io.Reader, writer io.Writer) (io.Reader, io.Writer)
+	AllowRecv(n int) bool
+	AllowSend(n int) bool
+}
+
+func NewTrafficLimiter(recv_limit, send_limit int) *trafficLimiter {
+	var recv_limiter *rate.Limiter
+	if recv_limit == 0 {
+		recv_limiter = nil
+	} else {
+		recv_limiter = createLimiter(recv_limit)
+	}
+	var send_limiter *rate.Limiter
+	if send_limit == 0 {
+		send_limiter = nil
+	} else {
+		send_limiter = createLimiter(send_limit)
+	}
+	return &trafficLimiter{recv_limiter: recv_limiter, send_limiter: send_limiter}
+}
+
+type trafficLimiter struct {
+	recv_limiter *rate.Limiter
+	send_limiter *rate.Limiter
+}
+
+// doWait does the waiting for any n, even exceeding the burst limit.
+func doWait(l *rate.Limiter, n int) error {
+	ctx := context.TODO()
+	b := l.Burst()
+	for b < n {
+		err := l.WaitN(ctx, b)
+		if err != nil {
+			return err
+		}
+		n -= b
+	}
+	return l.WaitN(ctx, n)
+}
+
+type limitedReader struct {
+	reader  io.Reader
+	limiter *rate.Limiter
+}
+
+func (r *limitedReader) Read(b []byte) (int, error) {
+	n, err := r.reader.Read(b)
+	if n <= 0 {
+		return n, err
+	}
+	waitErr := doWait(r.limiter, n)
+	if waitErr != nil {
+		return 0, waitErr
+	}
+	return n, err
+}
+
+type limitedWriter struct {
+	writer  io.Writer
+	limiter *rate.Limiter
+}
+
+func (w *limitedWriter) Write(b []byte) (int, error) {
+	n, err := w.writer.Write(b)
+	if n <= 0 {
+		return n, err
+	}
+	waitErr := doWait(w.limiter, n)
+	if waitErr != nil {
+		return 0, waitErr
+	}
+	return n, err
+}
+
+func createLimiter(limit int) *rate.Limiter {
+	burst := limit
+	theRate := rate.Every(time.Second) * rate.Limit(burst)
+	return rate.NewLimiter(theRate, burst)
+}
+
+func (l *trafficLimiter) WrapReaderWriter(reader io.Reader, writer io.Writer) (io.Reader, io.Writer) {
+	if l.recv_limiter == nil && l.send_limiter == nil {
+		return reader, writer
+	}
+	if l.recv_limiter == nil {
+		return &limitedReader{reader: reader, limiter: l.recv_limiter}, writer
+	}
+	if l.send_limiter == nil {
+		return reader, &limitedWriter{writer: writer, limiter: l.send_limiter}
+	}
+
+	return &limitedReader{reader: reader, limiter: l.recv_limiter}, &limitedWriter{writer: writer, limiter: l.send_limiter}
+}
+
+func (l *trafficLimiter) AllowRecv(n int) bool {
+	if l.recv_limiter == nil {
+		return true
+	}
+	return l.recv_limiter.AllowN(time.Now(), n)
+}
+
+func (l *trafficLimiter) AllowSend(n int) bool {
+	if l.send_limiter == nil {
+		return true
+	}
+	return l.send_limiter.AllowN(time.Now(), n)
+}
diff --git a/service/limiter_test.go b/service/limiter_test.go
new file mode 100644
index 0000000..c825488
--- /dev/null
+++ b/service/limiter_test.go
@@ -0,0 +1,120 @@
+// Copyright 2020 Jigsaw Operations LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package service
+
+import (
+	"bytes"
+	"crypto/rand"
+	"io"
+	"testing"
+	"time"
+
+	"github.com/stretchr/testify/require"
+)
+
+func makeRandBuffer(n int64) *bytes.Buffer {
+	arr := make([]byte, n)
+	rand.Read(arr)
+	return bytes.NewBuffer(arr)
+}
+
+func TestTrafficLimiter(t *testing.T) {
+	lim1 := NewTrafficLimiter(20, 20)
+	lim2 := NewTrafficLimiter(30, 30)
+	lim3 := NewTrafficLimiter(0, 0)
+
+	src1Buf := makeRandBuffer(100)
+	src1 := src1Buf.Bytes()
+	dst1 := &bytes.Buffer{}
+
+	src2Buf := makeRandBuffer(100)
+	src2 := src2Buf.Bytes()
+	dst2 := &bytes.Buffer{}
+
+	src3Buf := makeRandBuffer(100)
+	src3 := src3Buf.Bytes()
+	dst3 := &bytes.Buffer{}
+
+	r1, w1 := lim1.WrapReaderWriter(src1Buf, dst1)
+	r2, w2 := lim2.WrapReaderWriter(src2Buf, dst2)
+	r3, w3 := lim3.WrapReaderWriter(src3Buf, dst3)
+
+	doRead := func(buf []byte, r io.Reader, n int) time.Duration {
+		b := make([]byte, n)
+		start := time.Now()
+		_, err := io.ReadFull(r, b)
+		require.NoError(t, err)
+		require.Equal(t, b, buf[:len(b)])
+		return time.Since(start)
+	}
+
+	period1 := doRead(src1, r1, 20)
+	if period1 > 10*time.Millisecond {
+		t.Errorf("read took too long: %s", period1)
+	}
+
+	allowed := lim2.AllowRecv(10)
+	require.True(t, allowed)
+
+	period2 := doRead(src2, r2, 70)
+	if period2 < time.Second {
+		t.Errorf("read took too short: %s", period2)
+	}
+
+	allowed = lim2.AllowRecv(10)
+	require.False(t, allowed)
+
+	period3 := doRead(src3, r3, 100)
+	if period3 > 10*time.Millisecond {
+		t.Errorf("read took too long: %s", period3)
+	}
+
+	allowed = lim3.AllowRecv(100)
+	require.True(t, allowed)
+
+	doWrite := func(buf []byte, dst *bytes.Buffer, w io.Writer) time.Duration {
+		start := time.Now()
+		size := len(buf)
+		_, err := w.Write(buf)
+		require.NoError(t, err)
+		require.Equal(t, buf, dst.Bytes()[:size])
+		return time.Since(start)
+	}
+
+	// Waiting works even for payload exceeding one second burst.
+	period4 := doWrite(src1[:30], dst1, w1)
+	if period4 < 500*time.Millisecond {
+		t.Fatalf("write took too short: %s", period4)
+	}
+
+	allowed = lim2.AllowSend(20)
+	require.True(t, allowed)
+
+	allowed = lim2.AllowSend(20)
+	require.False(t, allowed)
+
+	period5 := doWrite(src2[:30], dst2, w2)
+	if period5 < 500*time.Millisecond {
+		t.Fatalf("write took too short: %s", period5)
+	}
+
+	allowed = lim3.AllowSend(1000)
+	require.True(t, allowed)
+
+	period6 := doWrite(src3[:100], dst3, w3)
+	if period6 > 10*time.Millisecond {
+		t.Fatalf("write took too long: %s", period6)
+	}
+}
diff --git a/service/tcp.go b/service/tcp.go
index d295931..46b5259 100644
--- a/service/tcp.go
+++ b/service/tcp.go
@@ -130,7 +130,9 @@ type tcpHandler struct {
 
 // NewTCPService creates a TCPService
 // `replayCache` is a pointer to SSServer.replayCache, to share the cache among all ports.
-func NewTCPHandler(port int, ciphers CipherList, replayCache *ReplayCache, m TCPMetrics, timeout time.Duration) TCPHandler {
+func NewTCPHandler(port int, ciphers CipherList, replayCache *ReplayCache, m TCPMetrics,
+	timeout time.Duration,
+) TCPHandler {
 	return &tcpHandler{
 		port:              port,
 		ciphers:           ciphers,
@@ -252,9 +254,13 @@ func (h *tcpHandler) handleConnection(listenerPort int, clientConn transport.Str
 		h.absorbProbe(listenerPort, clientConn, status, proxyMetrics)
 		return "", onet.NewConnectionError(status, "Failed to find a valid cipher", keyErr)
 	}
-	var id string
+	var (
+		id           string
+		clientWriter io.Writer = clientConn
+	)
 	if cipherEntry != nil {
 		id = cipherEntry.ID
+		clientReader, clientWriter = cipherEntry.TrafficLimiter.WrapReaderWriter(clientReader, clientWriter)
 	}
 
 	// 2. Check if the connection is a replay.
@@ -279,9 +285,10 @@ func (h *tcpHandler) handleConnection(listenerPort int, clientConn transport.Str
 	clientConn.SetReadDeadline(time.Time{})
 	if err != nil {
 		// Drain to prevent a close on cipher error.
-		io.Copy(io.Discard, clientConn)
+		io.Copy(io.Discard, clientReader)
 		return id, onet.NewConnectionError("ERR_READ_ADDRESS", "Failed to get target address", err)
 	}
+	logger.Debugf("address %s", clientConn.RemoteAddr().String())
 	tgtConn, dialErr := dialTarget(tgtAddr, proxyMetrics, h.targetIPValidator)
 	if dialErr != nil {
 		// We don't drain so dial errors and invalid addresses are communicated quickly.
@@ -291,15 +298,16 @@ func (h *tcpHandler) handleConnection(listenerPort int, clientConn transport.Str
 
 	// 4. Bridge the client and target connections
 	logger.Debugf("proxy %s <-> %s", clientConn.RemoteAddr().String(), tgtConn.RemoteAddr().String())
-	ssw := shadowsocks.NewWriter(clientConn, cipherEntry.CryptoKey)
+	ssw := shadowsocks.NewWriter(clientWriter, cipherEntry.CryptoKey)
 	ssw.SetSaltGenerator(cipherEntry.SaltGenerator)
 
 	fromClientErrCh := make(chan error)
 	go func() {
 		_, fromClientErr := ssr.WriteTo(tgtConn)
+		logger.Debugf("fromClientErr: %v", fromClientErr)
 		if fromClientErr != nil {
 			// Drain to prevent a close in the case of a cipher error.
-			io.Copy(io.Discard, clientConn)
+			io.Copy(io.Discard, clientReader)
 		}
 		clientConn.CloseRead()
 		// Send FIN to target.
@@ -353,6 +361,7 @@ var _ TCPMetrics = (*NoOpTCPMetrics)(nil)
 
 func (m *NoOpTCPMetrics) AddClosedTCPConnection(clientInfo ipinfo.IPInfo, accessKey, status string, data metrics.ProxyMetrics, duration time.Duration) {
 }
+
 func (m *NoOpTCPMetrics) GetIPInfo(net.IP) (ipinfo.IPInfo, error) {
 	return ipinfo.IPInfo{}, nil
 }
diff --git a/service/tcp_test.go b/service/tcp_test.go
index 1f38111..b6062bf 100644
--- a/service/tcp_test.go
+++ b/service/tcp_test.go
@@ -84,7 +84,7 @@ func BenchmarkTCPFindCipherFail(b *testing.B) {
 		b.Fatalf("ListenTCP failed: %v", err)
 	}
 
-	cipherList, err := MakeTestCiphers(makeTestSecrets(100))
+	cipherList, err := MakeTestCiphers(makeTestSecrets(100), 0, 0)
 	if err != nil {
 		b.Fatal(err)
 	}
@@ -187,7 +187,7 @@ func BenchmarkTCPFindCipherRepeat(b *testing.B) {
 	b.ResetTimer()
 
 	const numCiphers = 100 // Must be <256
-	cipherList, err := MakeTestCiphers(makeTestSecrets(numCiphers))
+	cipherList, err := MakeTestCiphers(makeTestSecrets(numCiphers), 0, 0)
 	if err != nil {
 		b.Fatal(err)
 	}
@@ -233,8 +233,10 @@ func (m *probeTestMetrics) AddClosedTCPConnection(clientInfo ipinfo.IPInfo, acce
 func (m *probeTestMetrics) GetIPInfo(net.IP) (ipinfo.IPInfo, error) {
 	return ipinfo.IPInfo{}, nil
 }
+
 func (m *probeTestMetrics) AddOpenTCPConnection(clientInfo ipinfo.IPInfo) {
 }
+
 func (m *probeTestMetrics) AddTCPProbe(status, drainResult string, port int, clientProxyBytes int64) {
 	m.mu.Lock()
 	m.probeData = append(m.probeData, clientProxyBytes)
@@ -273,7 +275,7 @@ func probe(serverAddr *net.TCPAddr, bytesToSend []byte) error {
 
 func TestProbeRandom(t *testing.T) {
 	listener := makeLocalhostListener(t)
-	cipherList, err := MakeTestCiphers(makeTestSecrets(1))
+	cipherList, err := MakeTestCiphers(makeTestSecrets(1), 0, 0)
 	require.NoError(t, err, "MakeTestCiphers failed: %v", err)
 	testMetrics := &probeTestMetrics{}
 	handler := NewTCPHandler(listener.Addr().(*net.TCPAddr).Port, cipherList, nil, testMetrics, 200*time.Millisecond)
@@ -348,7 +350,7 @@ func firstCipher(cipherList CipherList) *shadowsocks.EncryptionKey {
 
 func TestProbeClientBytesBasicTruncated(t *testing.T) {
 	listener := makeLocalhostListener(t)
-	cipherList, err := MakeTestCiphers(makeTestSecrets(1))
+	cipherList, err := MakeTestCiphers(makeTestSecrets(1), 0, 0)
 	require.NoError(t, err, "MakeTestCiphers failed: %v", err)
 	cipher := firstCipher(cipherList)
 	testMetrics := &probeTestMetrics{}
@@ -383,7 +385,7 @@ func TestProbeClientBytesBasicTruncated(t *testing.T) {
 
 func TestProbeClientBytesBasicModified(t *testing.T) {
 	listener := makeLocalhostListener(t)
-	cipherList, err := MakeTestCiphers(makeTestSecrets(1))
+	cipherList, err := MakeTestCiphers(makeTestSecrets(1), 0, 0)
 	require.NoError(t, err, "MakeTestCiphers failed: %v", err)
 	cipher := firstCipher(cipherList)
 	testMetrics := &probeTestMetrics{}
@@ -419,7 +421,7 @@ func TestProbeClientBytesBasicModified(t *testing.T) {
 
 func TestProbeClientBytesCoalescedModified(t *testing.T) {
 	listener := makeLocalhostListener(t)
-	cipherList, err := MakeTestCiphers(makeTestSecrets(1))
+	cipherList, err := MakeTestCiphers(makeTestSecrets(1), 0, 0)
 	require.NoError(t, err, "MakeTestCiphers failed: %v", err)
 	cipher := firstCipher(cipherList)
 	testMetrics := &probeTestMetrics{}
@@ -462,7 +464,7 @@ func makeServerBytes(t *testing.T, cryptoKey *shadowsocks.EncryptionKey) []byte
 
 func TestProbeServerBytesModified(t *testing.T) {
 	listener := makeLocalhostListener(t)
-	cipherList, err := MakeTestCiphers(makeTestSecrets(1))
+	cipherList, err := MakeTestCiphers(makeTestSecrets(1), 0, 0)
 	require.NoError(t, err, "MakeTestCiphers failed: %v", err)
 	cipher := firstCipher(cipherList)
 	testMetrics := &probeTestMetrics{}
@@ -491,7 +493,7 @@ func TestProbeServerBytesModified(t *testing.T) {
 
 func TestReplayDefense(t *testing.T) {
 	listener := makeLocalhostListener(t)
-	cipherList, err := MakeTestCiphers(makeTestSecrets(1))
+	cipherList, err := MakeTestCiphers(makeTestSecrets(1), 0, 0)
 	require.NoError(t, err, "MakeTestCiphers failed: %v", err)
 	replayCache := NewReplayCache(5)
 	testMetrics := &probeTestMetrics{}
@@ -569,7 +571,7 @@ func TestReplayDefense(t *testing.T) {
 
 func TestReverseReplayDefense(t *testing.T) {
 	listener := makeLocalhostListener(t)
-	cipherList, err := MakeTestCiphers(makeTestSecrets(1))
+	cipherList, err := MakeTestCiphers(makeTestSecrets(1), 0, 0)
 	require.NoError(t, err, "MakeTestCiphers failed: %v", err)
 	replayCache := NewReplayCache(5)
 	testMetrics := &probeTestMetrics{}
@@ -641,7 +643,7 @@ func probeExpectTimeout(t *testing.T, payloadSize int) {
 	const testTimeout = 200 * time.Millisecond
 
 	listener := makeLocalhostListener(t)
-	cipherList, err := MakeTestCiphers(makeTestSecrets(5))
+	cipherList, err := MakeTestCiphers(makeTestSecrets(5), 0, 0)
 	require.NoError(t, err, "MakeTestCiphers failed: %v", err)
 	testMetrics := &probeTestMetrics{}
 	handler := NewTCPHandler(listener.Addr().(*net.TCPAddr).Port, cipherList, nil, testMetrics, testTimeout)
diff --git a/service/udp.go b/service/udp.go
index 4138ed8..defb028 100644
--- a/service/udp.go
+++ b/service/udp.go
@@ -18,6 +18,7 @@ import (
 	"errors"
 	"fmt"
 	"net"
+	"os"
 	"runtime/debug"
 	"sync"
 	"time"
@@ -64,12 +65,13 @@ func debugUDPAddr(addr net.Addr, template string, val interface{}) {
 
 // Decrypts src into dst. It tries each cipher until it finds one that authenticates
 // correctly. dst and src must not overlap.
-func findAccessKeyUDP(clientIP net.IP, dst, src []byte, cipherList CipherList) ([]byte, string, *shadowsocks.EncryptionKey, error) {
+func findAccessKeyUDP(clientIP net.IP, dst, src []byte, cipherList CipherList) ([]byte, string, *shadowsocks.EncryptionKey, TrafficLimiter, error) {
 	// Try each cipher until we find one that authenticates successfully. This assumes that all ciphers are AEAD.
 	// We snapshot the list because it may be modified while we use it.
 	snapshot := cipherList.SnapshotForClientIP(clientIP)
 	for ci, entry := range snapshot {
 		id, cryptoKey := entry.Value.(*CipherEntry).ID, entry.Value.(*CipherEntry).CryptoKey
+		limiter := entry.Value.(*CipherEntry).TrafficLimiter
 		buf, err := shadowsocks.Unpack(dst, src, cryptoKey)
 		if err != nil {
 			debugUDP(id, "Failed to unpack: %v", err)
@@ -78,9 +80,9 @@ func findAccessKeyUDP(clientIP net.IP, dst, src []byte, cipherList CipherList) (
 		debugUDP(id, "Found cipher at index %d", ci)
 		// Move the active cipher to the front, so that the search is quicker next time.
 		cipherList.MarkUsedByClientIP(entry, clientIP)
-		return buf, id, cryptoKey, nil
+		return buf, id, cryptoKey, limiter, nil
 	}
-	return nil, "", nil, errors.New("could not find valid cipher")
+	return nil, "", nil, nil, errors.New("could not find valid cipher")
 }
 
 type packetHandler struct {
@@ -92,7 +94,12 @@ type packetHandler struct {
 
 // NewPacketHandler creates a UDPService
 func NewPacketHandler(natTimeout time.Duration, cipherList CipherList, m UDPMetrics) PacketHandler {
-	return &packetHandler{natTimeout: natTimeout, ciphers: cipherList, m: m, targetIPValidator: onet.RequirePublicIP}
+	return &packetHandler{
+		natTimeout:        natTimeout,
+		ciphers:           cipherList,
+		m:                 m,
+		targetIPValidator: onet.RequirePublicIP,
+	}
 }
 
 // PacketHandler is a running UDP shadowsocks proxy that can be stopped.
@@ -126,6 +133,7 @@ func (h *packetHandler) Handle(clientConn net.PacketConn) {
 		var clientInfo ipinfo.IPInfo
 		keyID := ""
 		var proxyTargetBytes int
+		var limiter TrafficLimiter
 
 		connError := func() (connError *onet.ConnectionError) {
 			defer func() {
@@ -160,7 +168,7 @@ func (h *packetHandler) Handle(clientConn net.PacketConn) {
 				var textData []byte
 				var cryptoKey *shadowsocks.EncryptionKey
 				unpackStart := time.Now()
-				textData, keyID, cryptoKey, err = findAccessKeyUDP(ip, textBuf, cipherData, h.ciphers)
+				textData, keyID, cryptoKey, limiter, err = findAccessKeyUDP(ip, textBuf, cipherData, h.ciphers)
 				timeToCipher := time.Since(unpackStart)
 				h.m.AddUDPCipherSearch(err == nil, timeToCipher)
 
@@ -177,7 +185,7 @@ func (h *packetHandler) Handle(clientConn net.PacketConn) {
 				if err != nil {
 					return onet.NewConnectionError("ERR_CREATE_SOCKET", "Failed to create UDP socket", err)
 				}
-				targetConn = nm.Add(clientAddr, clientConn, cryptoKey, udpConn, clientInfo, keyID)
+				targetConn = nm.Add(clientAddr, clientConn, cryptoKey, udpConn, clientInfo, keyID, limiter)
 			} else {
 				clientInfo = targetConn.clientInfo
 
@@ -192,6 +200,8 @@ func (h *packetHandler) Handle(clientConn net.PacketConn) {
 
 				// The key ID is known with confidence once decryption succeeds.
 				keyID = targetConn.keyID
+				limiter = targetConn.limiter
+				fmt.Fprintf(os.Stderr, "**2** limiter: %v\n", limiter)
 
 				var onetErr *onet.ConnectionError
 				if payload, tgtUDPAddr, onetErr = h.validatePacket(textData); onetErr != nil {
@@ -200,6 +210,11 @@ func (h *packetHandler) Handle(clientConn net.PacketConn) {
 			}
 
 			debugUDPAddr(clientAddr, "Proxy exit %v", targetConn.LocalAddr())
+			allowed := limiter.AllowRecv(len(payload))
+			if !allowed {
+				debugUDPAddr(clientAddr, "Rate limite exceeded, dropping packet from client (len %v)", len(payload))
+				return onet.NewConnectionError("ERR_LIMIT", "Rate limit exceeded", nil)
+			}
 			proxyTargetBytes, err = targetConn.WriteTo(payload, tgtUDPAddr) // accept only UDPAddr despite the signature
 			if err != nil {
 				return onet.NewConnectionError("ERR_WRITE", "Failed to write to target", err)
@@ -246,6 +261,7 @@ type natconn struct {
 	net.PacketConn
 	cryptoKey *shadowsocks.EncryptionKey
 	keyID     string
+	limiter   TrafficLimiter
 	// We store the client information in the NAT map to avoid recomputing it
 	// for every downstream packet in a UDP-based connection.
 	clientInfo ipinfo.IPInfo
@@ -326,11 +342,14 @@ func (m *natmap) Get(key string) *natconn {
 	return m.keyConn[key]
 }
 
-func (m *natmap) set(key string, pc net.PacketConn, cryptoKey *shadowsocks.EncryptionKey, keyID string, clientInfo ipinfo.IPInfo) *natconn {
+func (m *natmap) set(key string, pc net.PacketConn, cryptoKey *shadowsocks.EncryptionKey, keyID string, clientInfo ipinfo.IPInfo,
+	limiter TrafficLimiter,
+) *natconn {
 	entry := &natconn{
 		PacketConn:     pc,
 		cryptoKey:      cryptoKey,
 		keyID:          keyID,
+		limiter:        limiter,
 		clientInfo:     clientInfo,
 		defaultTimeout: m.timeout,
 	}
@@ -354,13 +373,15 @@ func (m *natmap) del(key string) net.PacketConn {
 	return nil
 }
 
-func (m *natmap) Add(clientAddr net.Addr, clientConn net.PacketConn, cryptoKey *shadowsocks.EncryptionKey, targetConn net.PacketConn, clientInfo ipinfo.IPInfo, keyID string) *natconn {
-	entry := m.set(clientAddr.String(), targetConn, cryptoKey, keyID, clientInfo)
+func (m *natmap) Add(clientAddr net.Addr, clientConn net.PacketConn, cryptoKey *shadowsocks.EncryptionKey, targetConn net.PacketConn, clientInfo ipinfo.IPInfo,
+	keyID string, limiter TrafficLimiter,
+) *natconn {
+	entry := m.set(clientAddr.String(), targetConn, cryptoKey, keyID, clientInfo, limiter)
 
 	m.metrics.AddUDPNatEntry()
 	m.running.Add(1)
 	go func() {
-		timedCopy(clientAddr, clientConn, entry, keyID, m.metrics)
+		timedCopy(clientAddr, clientConn, entry, keyID, m.metrics, limiter)
 		m.metrics.RemoveUDPNatEntry()
 		if pc := m.del(clientAddr.String()); pc != nil {
 			pc.Close()
@@ -390,7 +411,8 @@ var maxAddrLen int = len(socks.ParseAddr("[2001:db8::1]:12345"))
 
 // copy from target to client until read timeout
 func timedCopy(clientAddr net.Addr, clientConn net.PacketConn, targetConn *natconn,
-	keyID string, sm UDPMetrics) {
+	keyID string, sm UDPMetrics, limiter TrafficLimiter,
+) {
 	// pkt is used for in-place encryption of downstream UDP packets, with the layout
 	// [padding?][salt][address][body][tag][extra]
 	// Padding is only used if the address is IPv4.
@@ -424,6 +446,13 @@ func timedCopy(clientAddr net.Addr, clientConn net.PacketConn, targetConn *natco
 			}
 
 			debugUDPAddr(clientAddr, "Got response from %v", raddr)
+
+			allowed := limiter.AllowSend(bodyLen)
+			if !allowed {
+				debugUDPAddr(clientAddr, "Rate limite exceeded, dropping packet to client (len %v)", bodyLen)
+				return onet.NewConnectionError("ERR_LIMIT", "Rate limit exceeded", nil)
+			}
+
 			srcAddr := socks.ParseAddr(raddr.String())
 			addrStart := bodyStart - len(srcAddr)
 			// `plainTextBuf` concatenates the SOCKS address and body:
@@ -471,8 +500,10 @@ var _ UDPMetrics = (*NoOpUDPMetrics)(nil)
 func (m *NoOpUDPMetrics) GetIPInfo(net.IP) (ipinfo.IPInfo, error) {
 	return ipinfo.IPInfo{}, nil
 }
+
 func (m *NoOpUDPMetrics) AddUDPPacketFromClient(clientInfo ipinfo.IPInfo, accessKey, status string, clientProxyBytes, proxyTargetBytes int) {
 }
+
 func (m *NoOpUDPMetrics) AddUDPPacketFromTarget(clientInfo ipinfo.IPInfo, accessKey, status string, targetProxyBytes, proxyClientBytes int) {
 }
 func (m *NoOpUDPMetrics) AddUDPNatEntry()                                                    {}
diff --git a/service/udp_test.go b/service/udp_test.go
index 27756e3..236554a 100644
--- a/service/udp_test.go
+++ b/service/udp_test.go
@@ -25,6 +25,7 @@ import (
 	"github.com/Jigsaw-Code/outline-sdk/transport/shadowsocks"
 	"github.com/Jigsaw-Code/outline-ss-server/ipinfo"
 	onet "github.com/Jigsaw-Code/outline-ss-server/net"
+	ss "github.com/Jigsaw-Code/outline-ss-server/shadowsocks"
 	logging "github.com/op/go-logging"
 	"github.com/shadowsocks/go-shadowsocks2/socks"
 	"github.com/stretchr/testify/assert"
@@ -33,10 +34,12 @@ import (
 
 const timeout = 5 * time.Minute
 
-var clientAddr = net.UDPAddr{IP: []byte{192, 0, 2, 1}, Port: 12345}
-var targetAddr = net.UDPAddr{IP: []byte{192, 0, 2, 2}, Port: 54321}
-var dnsAddr = net.UDPAddr{IP: []byte{192, 0, 2, 3}, Port: 53}
-var natCryptoKey *shadowsocks.EncryptionKey
+var (
+	clientAddr   = net.UDPAddr{IP: []byte{192, 0, 2, 1}, Port: 12345}
+	targetAddr   = net.UDPAddr{IP: []byte{192, 0, 2, 2}, Port: 54321}
+	dnsAddr      = net.UDPAddr{IP: []byte{192, 0, 2, 3}, Port: 53}
+	natCryptoKey *shadowsocks.EncryptionKey
+)
 
 func init() {
 	logging.SetLevel(logging.INFO, "")
@@ -108,11 +111,14 @@ var _ UDPMetrics = (*natTestMetrics)(nil)
 func (m *natTestMetrics) GetIPInfo(net.IP) (ipinfo.IPInfo, error) {
 	return ipinfo.IPInfo{}, nil
 }
+
 func (m *natTestMetrics) AddUDPPacketFromClient(clientInfo ipinfo.IPInfo, accessKey, status string, clientProxyBytes, proxyTargetBytes int) {
 	m.upstreamPackets = append(m.upstreamPackets, udpReport{clientInfo, accessKey, status, clientProxyBytes, proxyTargetBytes})
 }
+
 func (m *natTestMetrics) AddUDPPacketFromTarget(clientInfo ipinfo.IPInfo, accessKey, status string, targetProxyBytes, proxyClientBytes int) {
 }
+
 func (m *natTestMetrics) AddUDPNatEntry() {
 	m.natEntriesAdded++
 }
@@ -122,7 +128,7 @@ func (m *natTestMetrics) AddUDPCipherSearch(accessKeyFound bool, timeToCipher ti
 // Takes a validation policy, and returns the metrics it
 // generates when localhost access is attempted
 func sendToDiscard(payloads [][]byte, validator onet.TargetIPValidator) *natTestMetrics {
-	ciphers, _ := MakeTestCiphers([]string{"asdf"})
+	ciphers, _ := MakeTestCiphers([]string{"asdf"}, 0, 0)
 	cipher := ciphers.SnapshotForClientIP(nil)[0].Value.(*CipherEntry).CryptoKey
 	clientConn := makePacketConn()
 	metrics := &natTestMetrics{}
@@ -210,10 +216,16 @@ func TestNATEmpty(t *testing.T) {
 }
 
 func setupNAT() (*fakePacketConn, *fakePacketConn, *natconn) {
+	cipherList, err := MakeTestCiphers(ss.MakeTestSecrets(1), 0, 0)
+	if err != nil {
+		logger.Fatal(err)
+	}
 	nat := newNATmap(timeout, &natTestMetrics{}, &sync.WaitGroup{})
 	clientConn := makePacketConn()
 	targetConn := makePacketConn()
-	nat.Add(&clientAddr, clientConn, natCryptoKey, targetConn, ipinfo.IPInfo{CountryCode: "ZZ"}, "key id")
+	entrySnap := cipherList.SnapshotForClientIP(net.IP{})[0].Value
+	key, limiter := entrySnap.(*CipherEntry).ID, entrySnap.(*CipherEntry).TrafficLimiter
+	nat.Add(&clientAddr, clientConn, natCryptoKey, targetConn, ipinfo.IPInfo{CountryCode: "ZZ"}, key, limiter)
 	entry := nat.Get(clientAddr.String())
 	return clientConn, targetConn, entry
 }
@@ -396,7 +408,7 @@ func TestNATTimeout(t *testing.T) {
 
 // Simulates receiving invalid UDP packets on a server with 100 ciphers.
 func BenchmarkUDPUnpackFail(b *testing.B) {
-	cipherList, err := MakeTestCiphers(makeTestSecrets(100))
+	cipherList, err := MakeTestCiphers(makeTestSecrets(100), 0, 0)
 	if err != nil {
 		b.Fatal(err)
 	}
@@ -413,7 +425,7 @@ func BenchmarkUDPUnpackFail(b *testing.B) {
 // their own cipher and IP address.
 func BenchmarkUDPUnpackRepeat(b *testing.B) {
 	const numCiphers = 100 // Must be <256
-	cipherList, err := MakeTestCiphers(makeTestSecrets(numCiphers))
+	cipherList, err := MakeTestCiphers(makeTestSecrets(numCiphers), 0, 0)
 	if err != nil {
 		b.Fatal(err)
 	}
@@ -435,7 +447,7 @@ func BenchmarkUDPUnpackRepeat(b *testing.B) {
 		cipherNumber := n % numCiphers
 		ip := ips[cipherNumber]
 		packet := packets[cipherNumber]
-		_, _, _, err := findAccessKeyUDP(ip, testBuf, packet, cipherList)
+		_, _, _, _, err := findAccessKeyUDP(ip, testBuf, packet, cipherList)
 		if err != nil {
 			b.Error(err)
 		}
@@ -445,7 +457,7 @@ func BenchmarkUDPUnpackRepeat(b *testing.B) {
 // Simulates receiving valid UDP packets from 100 different IP addresses,
 // all using the same cipher.
 func BenchmarkUDPUnpackSharedKey(b *testing.B) {
-	cipherList, err := MakeTestCiphers(makeTestSecrets(1)) // One widely shared key
+	cipherList, err := MakeTestCiphers(makeTestSecrets(1), 0, 0) // One widely shared key
 	if err != nil {
 		b.Fatal(err)
 	}
@@ -464,7 +476,7 @@ func BenchmarkUDPUnpackSharedKey(b *testing.B) {
 	b.ResetTimer()
 	for n := 0; n < b.N; n++ {
 		ip := ips[n%numIPs]
-		_, _, _, err := findAccessKeyUDP(ip, testBuf, packet, cipherList)
+		_, _, _, _, err := findAccessKeyUDP(ip, testBuf, packet, cipherList)
 		if err != nil {
 			b.Error(err)
 		}
@@ -472,7 +484,7 @@ func BenchmarkUDPUnpackSharedKey(b *testing.B) {
 }
 
 func TestUDPEarlyClose(t *testing.T) {
-	cipherList, err := MakeTestCiphers(makeTestSecrets(1))
+	cipherList, err := MakeTestCiphers(makeTestSecrets(1), 0, 0)
 	if err != nil {
 		t.Fatal(err)
 	}
